{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit'; // utils\n\nimport axios from '../../utils/axios'; //\n\nimport { dispatch } from '../store'; // ----------------------------------------------------------------------\n\nfunction objFromArray(array) {\n  let key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';\n  return array.reduce((accumulator, current) => {\n    accumulator[current[key]] = current;\n    return accumulator;\n  }, {});\n}\n\nconst initialState = {\n  isLoading: false,\n  error: null,\n  contacts: {\n    byId: {},\n    allIds: []\n  },\n  conversations: {\n    byId: {},\n    allIds: []\n  },\n  activeConversationId: null,\n  participants: [],\n  recipients: []\n};\nconst slice = createSlice({\n  name: 'chat',\n  initialState,\n  reducers: {\n    // START LOADING\n    startLoading(state) {\n      state.isLoading = true;\n    },\n\n    // HAS ERROR\n    hasError(state, action) {\n      state.isLoading = false;\n      state.error = action.payload;\n    },\n\n    // GET CONTACT SSUCCESS\n    getContactsSuccess(state, action) {\n      const contacts = action.payload;\n      state.contacts.byId = objFromArray(contacts);\n      state.contacts.allIds = Object.keys(state.contacts.byId);\n    },\n\n    // GET CONVERSATIONS\n    getConversationsSuccess(state, action) {\n      const conversations = action.payload;\n      state.conversations.byId = objFromArray(conversations);\n      state.conversations.allIds = Object.keys(state.conversations.byId);\n    },\n\n    // GET CONVERSATION\n    getConversationSuccess(state, action) {\n      const conversation = action.payload;\n\n      if (conversation) {\n        state.conversations.byId[conversation.id] = conversation;\n        state.activeConversationId = conversation.id;\n\n        if (!state.conversations.allIds.includes(conversation.id)) {\n          state.conversations.allIds.push(conversation.id);\n        }\n      } else {\n        state.activeConversationId = null;\n      }\n    },\n\n    // ON SEND MESSAGE\n    onSendMessage(state, action) {\n      const conversation = action.payload;\n      const {\n        conversationId,\n        messageId,\n        message,\n        contentType,\n        attachments,\n        createdAt,\n        senderId\n      } = conversation;\n      const newMessage = {\n        id: messageId,\n        body: message,\n        contentType,\n        attachments,\n        createdAt,\n        senderId\n      };\n      state.conversations.byId[conversationId].messages.push(newMessage);\n    },\n\n    markConversationAsReadSuccess(state, action) {\n      const {\n        conversationId\n      } = action.payload;\n      const conversation = state.conversations.byId[conversationId];\n\n      if (conversation) {\n        conversation.unreadCount = 0;\n      }\n    },\n\n    // GET PARTICIPANTS\n    getParticipantsSuccess(state, action) {\n      const participants = action.payload;\n      state.participants = participants;\n    },\n\n    // RESET ACTIVE CONVERSATION\n    resetActiveConversation(state) {\n      state.activeConversationId = null;\n    },\n\n    addRecipients(state, action) {\n      const recipients = action.payload;\n      state.recipients = recipients;\n    }\n\n  }\n}); // Reducer\n\nexport default slice.reducer; // Actions\n\nexport const {\n  addRecipients,\n  onSendMessage,\n  resetActiveConversation\n} = slice.actions; // ----------------------------------------------------------------------\n\nexport function getContacts() {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.get('/api/chat/contacts');\n      dispatch(slice.actions.getContactsSuccess(response.data.contacts));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getConversations() {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.get('/api/chat/conversations');\n      dispatch(slice.actions.getConversationsSuccess(response.data.conversations));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getConversation(conversationKey) {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.get('/api/chat/conversation', {\n        params: {\n          conversationKey\n        }\n      });\n      dispatch(slice.actions.getConversationSuccess(response.data.conversation));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function markConversationAsRead(conversationId) {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      await axios.get('/api/chat/conversation/mark-as-seen', {\n        params: {\n          conversationId\n        }\n      });\n      dispatch(slice.actions.markConversationAsReadSuccess({\n        conversationId\n      }));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n} // ----------------------------------------------------------------------\n\nexport function getParticipants(conversationKey) {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n\n    try {\n      const response = await axios.get('/api/chat/participants', {\n        params: {\n          conversationKey\n        }\n      });\n      dispatch(slice.actions.getParticipantsSuccess(response.data.participants));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}","map":{"version":3,"sources":["D:/Projects/Cdss apps/Final version/admin/src/redux/slices/chat.js"],"names":["createSlice","axios","dispatch","objFromArray","array","key","reduce","accumulator","current","initialState","isLoading","error","contacts","byId","allIds","conversations","activeConversationId","participants","recipients","slice","name","reducers","startLoading","state","hasError","action","payload","getContactsSuccess","Object","keys","getConversationsSuccess","getConversationSuccess","conversation","id","includes","push","onSendMessage","conversationId","messageId","message","contentType","attachments","createdAt","senderId","newMessage","body","messages","markConversationAsReadSuccess","unreadCount","getParticipantsSuccess","resetActiveConversation","addRecipients","reducer","actions","getContacts","response","get","data","getConversations","getConversation","conversationKey","params","markConversationAsRead","getParticipants"],"mappings":"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","sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n// utils\nimport axios from '../../utils/axios';\n//\nimport { dispatch } from '../store';\n\n// ----------------------------------------------------------------------\n\nfunction objFromArray(array, key = 'id') {\n  return array.reduce((accumulator, current) => {\n    accumulator[current[key]] = current;\n    return accumulator;\n  }, {});\n}\n\nconst initialState = {\n  isLoading: false,\n  error: null,\n  contacts: { byId: {}, allIds: [] },\n  conversations: { byId: {}, allIds: [] },\n  activeConversationId: null,\n  participants: [],\n  recipients: [],\n};\n\nconst slice = createSlice({\n  name: 'chat',\n  initialState,\n  reducers: {\n    // START LOADING\n    startLoading(state) {\n      state.isLoading = true;\n    },\n\n    // HAS ERROR\n    hasError(state, action) {\n      state.isLoading = false;\n      state.error = action.payload;\n    },\n\n    // GET CONTACT SSUCCESS\n    getContactsSuccess(state, action) {\n      const contacts = action.payload;\n\n      state.contacts.byId = objFromArray(contacts);\n      state.contacts.allIds = Object.keys(state.contacts.byId);\n    },\n\n    // GET CONVERSATIONS\n    getConversationsSuccess(state, action) {\n      const conversations = action.payload;\n\n      state.conversations.byId = objFromArray(conversations);\n      state.conversations.allIds = Object.keys(state.conversations.byId);\n    },\n\n    // GET CONVERSATION\n    getConversationSuccess(state, action) {\n      const conversation = action.payload;\n\n      if (conversation) {\n        state.conversations.byId[conversation.id] = conversation;\n        state.activeConversationId = conversation.id;\n        if (!state.conversations.allIds.includes(conversation.id)) {\n          state.conversations.allIds.push(conversation.id);\n        }\n      } else {\n        state.activeConversationId = null;\n      }\n    },\n\n    // ON SEND MESSAGE\n    onSendMessage(state, action) {\n      const conversation = action.payload;\n      const { conversationId, messageId, message, contentType, attachments, createdAt, senderId } = conversation;\n\n      const newMessage = {\n        id: messageId,\n        body: message,\n        contentType,\n        attachments,\n        createdAt,\n        senderId,\n      };\n\n      state.conversations.byId[conversationId].messages.push(newMessage);\n    },\n\n    markConversationAsReadSuccess(state, action) {\n      const { conversationId } = action.payload;\n      const conversation = state.conversations.byId[conversationId];\n      if (conversation) {\n        conversation.unreadCount = 0;\n      }\n    },\n\n    // GET PARTICIPANTS\n    getParticipantsSuccess(state, action) {\n      const participants = action.payload;\n      state.participants = participants;\n    },\n\n    // RESET ACTIVE CONVERSATION\n    resetActiveConversation(state) {\n      state.activeConversationId = null;\n    },\n\n    addRecipients(state, action) {\n      const recipients = action.payload;\n      state.recipients = recipients;\n    },\n  },\n});\n\n// Reducer\nexport default slice.reducer;\n\n// Actions\nexport const { addRecipients, onSendMessage, resetActiveConversation } = slice.actions;\n\n// ----------------------------------------------------------------------\n\nexport function getContacts() {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n    try {\n      const response = await axios.get('/api/chat/contacts');\n      dispatch(slice.actions.getContactsSuccess(response.data.contacts));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}\n\n// ----------------------------------------------------------------------\n\nexport function getConversations() {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n    try {\n      const response = await axios.get('/api/chat/conversations');\n      dispatch(slice.actions.getConversationsSuccess(response.data.conversations));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}\n\n// ----------------------------------------------------------------------\n\nexport function getConversation(conversationKey) {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n    try {\n      const response = await axios.get('/api/chat/conversation', {\n        params: { conversationKey },\n      });\n      dispatch(slice.actions.getConversationSuccess(response.data.conversation));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}\n\n// ----------------------------------------------------------------------\n\nexport function markConversationAsRead(conversationId) {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n    try {\n      await axios.get('/api/chat/conversation/mark-as-seen', {\n        params: { conversationId },\n      });\n      dispatch(slice.actions.markConversationAsReadSuccess({ conversationId }));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}\n\n// ----------------------------------------------------------------------\n\nexport function getParticipants(conversationKey) {\n  return async () => {\n    dispatch(slice.actions.startLoading());\n    try {\n      const response = await axios.get('/api/chat/participants', {\n        params: { conversationKey },\n      });\n      dispatch(slice.actions.getParticipantsSuccess(response.data.participants));\n    } catch (error) {\n      dispatch(slice.actions.hasError(error));\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module"}