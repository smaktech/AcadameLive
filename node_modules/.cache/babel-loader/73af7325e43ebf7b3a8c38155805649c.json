{"ast":null,"code":"/*!\nFullCalendar Scheduler v5.10.1\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2021 Adam Shaw\n*/\nimport './main.css';\nimport { config, createFormatter, greatestDurationDenominator, asCleanDays, createDuration, wholeDivideDurations, asRoughMs, addDays, startOfDay, asRoughSeconds, asRoughMinutes, diffWholeDays, isInt, computeVisibleDayRange, padStart, createElement, ContentHook, BaseComponent, memoizeObjArg, buildClassNameNormalizer, memoize, getDateMeta, getSlotClassNames, getDayClassNames, MountHook, buildNavLinkAttrs, Fragment, rangeContainsMarker, PositionCache, findDirectChildren, createRef, NowTimer, NowIndicatorRoot, findElements, RenderHook, RefMap, multiplyDuration, SegHierarchy, groupIntersectingEntries, buildIsoString, computeEarliestSegStart, buildEventRangeKey, BgEvent, getSegMeta, renderFill, intersectRanges, addMs, Slicer, StandardEvent, MoreLinkRoot, setRef, sortEventSegs, mapHash, isPropsEqual, DateComponent, getStickyHeaderDates, getStickyFooterScrollbar, ViewRoot, renderScrollShim, createPlugin } from '@fullcalendar/common';\nimport premiumCommonPlugin from '@fullcalendar/premium-common';\nimport { __extends, __assign } from 'tslib';\nimport { ScrollGrid } from '@fullcalendar/scrollgrid';\nvar MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\n\nvar MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\n\nvar MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\n\nconfig.MAX_TIMELINE_SLOTS = 1000; // potential nice values for slot-duration and interval-duration\n\nvar STOCK_SUB_DURATIONS = [{\n  years: 1\n}, {\n  months: 1\n}, {\n  days: 1\n}, {\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  minutes: 10\n}, {\n  minutes: 5\n}, {\n  minutes: 1\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}, {\n  seconds: 10\n}, {\n  seconds: 5\n}, {\n  seconds: 1\n}, {\n  milliseconds: 500\n}, {\n  milliseconds: 100\n}, {\n  milliseconds: 10\n}, {\n  milliseconds: 1\n}];\n\nfunction buildTimelineDateProfile(dateProfile, dateEnv, allOptions, dateProfileGenerator) {\n  var tDateProfile = {\n    labelInterval: allOptions.slotLabelInterval,\n    slotDuration: allOptions.slotDuration\n  };\n  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n\n  ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n  ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n  var input = allOptions.slotLabelFormat;\n  var rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions);\n  tDateProfile.headerFormats = rawFormats.map(function (rawFormat) {\n    return createFormatter(rawFormat);\n  });\n  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n  var largeUnit = null;\n\n  if (!tDateProfile.isTimeScale) {\n    var slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n\n    if (/year|month|week/.test(slotUnit)) {\n      largeUnit = slotUnit;\n    }\n  }\n\n  tDateProfile.largeUnit = largeUnit;\n  tDateProfile.emphasizeWeeks = asCleanDays(tDateProfile.slotDuration) === 1 && currentRangeAs('weeks', dateProfile, dateEnv) >= 2 && !allOptions.businessHours;\n  /*\n  console.log('label interval =', timelineView.labelInterval.humanize())\n  console.log('slot duration =', timelineView.slotDuration.humanize())\n  console.log('header formats =', timelineView.headerFormats)\n  console.log('isTimeScale', timelineView.isTimeScale)\n  console.log('largeUnit', timelineView.largeUnit)\n  */\n\n  var rawSnapDuration = allOptions.snapDuration;\n  var snapDuration;\n  var snapsPerSlot;\n\n  if (rawSnapDuration) {\n    snapDuration = createDuration(rawSnapDuration);\n    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration); // ^ TODO: warning if not whole?\n  }\n\n  if (snapsPerSlot == null) {\n    snapDuration = tDateProfile.slotDuration;\n    snapsPerSlot = 1;\n  }\n\n  tDateProfile.snapDuration = snapDuration;\n  tDateProfile.snapsPerSlot = snapsPerSlot; // more...\n\n  var timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime); // TODO: why not use normalizeRange!?\n\n  var normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n  var normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv); // apply slotMinTime/slotMaxTime\n  // TODO: View should be responsible.\n\n  if (tDateProfile.isTimeScale) {\n    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime);\n    normalizedEnd = dateEnv.add(addDays(normalizedEnd, -1), dateProfile.slotMaxTime);\n  }\n\n  tDateProfile.timeWindowMs = timeWindowMs;\n  tDateProfile.normalizedRange = {\n    start: normalizedStart,\n    end: normalizedEnd\n  };\n  var slotDates = [];\n  var date = normalizedStart;\n\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      slotDates.push(date);\n    }\n\n    date = dateEnv.add(date, tDateProfile.slotDuration);\n  }\n\n  tDateProfile.slotDates = slotDates; // more...\n\n  var snapIndex = -1;\n  var snapDiff = 0; // index of the diff :(\n\n  var snapDiffToIndex = [];\n  var snapIndexToDiff = [];\n  date = normalizedStart;\n\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      snapIndex += 1;\n      snapDiffToIndex.push(snapIndex);\n      snapIndexToDiff.push(snapDiff);\n    } else {\n      snapDiffToIndex.push(snapIndex + 0.5);\n    }\n\n    date = dateEnv.add(date, tDateProfile.snapDuration);\n    snapDiff += 1;\n  }\n\n  tDateProfile.snapDiffToIndex = snapDiffToIndex;\n  tDateProfile.snapIndexToDiff = snapIndexToDiff;\n  tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n\n  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot; // more...\n\n  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv);\n  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n  return tDateProfile;\n}\n/*\nsnaps to appropriate unit\n*/\n\n\nfunction normalizeDate(date, tDateProfile, dateEnv) {\n  var normalDate = date;\n\n  if (!tDateProfile.isTimeScale) {\n    normalDate = startOfDay(normalDate);\n\n    if (tDateProfile.largeUnit) {\n      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n    }\n  }\n\n  return normalDate;\n}\n/*\nsnaps to appropriate unit\n*/\n\n\nfunction normalizeRange(range, tDateProfile, dateEnv) {\n  if (!tDateProfile.isTimeScale) {\n    range = computeVisibleDayRange(range);\n\n    if (tDateProfile.largeUnit) {\n      var dayRange = range; // preserve original result\n\n      range = {\n        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n        end: dateEnv.startOf(range.end, tDateProfile.largeUnit)\n      }; // if date is partially through the interval, or is in the same interval as the start,\n      // make the exclusive end be the *next* interval\n\n      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n        range = {\n          start: range.start,\n          end: dateEnv.add(range.end, tDateProfile.slotDuration)\n        };\n      }\n    }\n  }\n\n  return range;\n}\n\nfunction isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator) {\n  if (dateProfileGenerator.isHiddenDay(date)) {\n    return false;\n  }\n\n  if (tDateProfile.isTimeScale) {\n    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n    var day = startOfDay(date);\n    var timeMs = date.valueOf() - day.valueOf();\n    var ms = timeMs - asRoughMs(dateProfile.slotMinTime); // milliseconds since slotMinTime\n\n    ms = (ms % 86400000 + 86400000) % 86400000; // make negative values wrap to 24hr clock\n\n    return ms < tDateProfile.timeWindowMs; // before the slotMaxTime?\n  }\n\n  return true;\n}\n\nfunction validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange; // make sure labelInterval doesn't exceed the max number of cells\n\n  if (tDateProfile.labelInterval) {\n    var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n\n    if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotLabelInterval results in too many cells');\n      tDateProfile.labelInterval = null;\n    }\n  } // make sure slotDuration doesn't exceed the maximum number of cells\n\n\n  if (tDateProfile.slotDuration) {\n    var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n\n    if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotDuration results in too many cells');\n      tDateProfile.slotDuration = null;\n    }\n  } // make sure labelInterval is a multiple of slotDuration\n\n\n  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n    var slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n\n    if (slotsPerLabel === null || slotsPerLabel < 1) {\n      console.warn('slotLabelInterval must be a multiple of slotDuration');\n      tDateProfile.slotDuration = null;\n    }\n  }\n}\n\nfunction ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  var labelInterval = tDateProfile.labelInterval;\n\n  if (!labelInterval) {\n    // compute based off the slot duration\n    // find the largest label interval with an acceptable slots-per-label\n    var input = void 0;\n\n    if (tDateProfile.slotDuration) {\n      for (var _i = 0, STOCK_SUB_DURATIONS_1 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_1.length; _i++) {\n        input = STOCK_SUB_DURATIONS_1[_i];\n        var tryLabelInterval = createDuration(input);\n        var slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n\n        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          labelInterval = tryLabelInterval;\n          break;\n        }\n      } // use the slot duration as a last resort\n\n\n      if (!labelInterval) {\n        labelInterval = tDateProfile.slotDuration;\n      } // compute based off the view's duration\n      // find the largest label interval that yields the minimum number of labels\n\n    } else {\n      for (var _a = 0, STOCK_SUB_DURATIONS_2 = STOCK_SUB_DURATIONS; _a < STOCK_SUB_DURATIONS_2.length; _a++) {\n        input = STOCK_SUB_DURATIONS_2[_a];\n        labelInterval = createDuration(input);\n        var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n\n        if (labelCnt >= MIN_AUTO_LABELS) {\n          break;\n        }\n      }\n    }\n\n    tDateProfile.labelInterval = labelInterval;\n  }\n\n  return labelInterval;\n}\n\nfunction ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n  var currentRange = dateProfile.currentRange;\n  var slotDuration = tDateProfile.slotDuration;\n\n  if (!slotDuration) {\n    var labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n    // compute based off the label interval\n    // find the largest slot duration that is different from labelInterval, but still acceptable\n\n    for (var _i = 0, STOCK_SUB_DURATIONS_3 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_3.length; _i++) {\n      var input = STOCK_SUB_DURATIONS_3[_i];\n      var trySlotDuration = createDuration(input);\n      var slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration);\n\n      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n        slotDuration = trySlotDuration;\n        break;\n      }\n    } // only allow the value if it won't exceed the view's # of slots limit\n\n\n    if (slotDuration) {\n      var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n\n      if (slotCnt > MAX_AUTO_CELLS) {\n        slotDuration = null;\n      }\n    } // use the label interval as a last resort\n\n\n    if (!slotDuration) {\n      slotDuration = labelInterval;\n    }\n\n    tDateProfile.slotDuration = slotDuration;\n  }\n\n  return slotDuration;\n}\n\nfunction computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions) {\n  var format1;\n  var format2;\n  var labelInterval = tDateProfile.labelInterval;\n  var unit = greatestDurationDenominator(labelInterval).unit;\n  var weekNumbersVisible = allOptions.weekNumbers;\n  var format0 = format1 = format2 = null; // NOTE: weekNumber computation function wont work\n\n  if (unit === 'week' && !weekNumbersVisible) {\n    unit = 'day';\n  }\n\n  switch (unit) {\n    case 'year':\n      format0 = {\n        year: 'numeric'\n      }; // '2015'\n\n      break;\n\n    case 'month':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        month: 'short'\n      }; // 'Jan'\n\n      break;\n\n    case 'week':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n      }\n\n      format1 = {\n        week: 'narrow'\n      }; // 'Wk4'\n\n      break;\n\n    case 'day':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = {\n          year: 'numeric',\n          month: 'long'\n        }; // 'January 2014'\n      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n        format0 = {\n          month: 'long'\n        }; // 'January'\n      }\n\n      if (weekNumbersVisible) {\n        format1 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      format2 = {\n        weekday: 'narrow',\n        day: 'numeric'\n      }; // 'Su 9'\n\n      break;\n\n    case 'hour':\n      if (weekNumbersVisible) {\n        format0 = {\n          week: 'short'\n        }; // 'Wk 4'\n      }\n\n      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n        format1 = {\n          weekday: 'short',\n          day: 'numeric',\n          month: 'numeric',\n          omitCommas: true\n        }; // Sat 4/7\n      }\n\n      format2 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short'\n      };\n      break;\n\n    case 'minute':\n      // sufficiently large number of different minute cells?\n      if (asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          meridiem: 'short'\n        };\n\n        format1 = function format1(params) {\n          return ':' + padStart(params.date.minute, 2) // ':30'\n          ;\n        };\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: 'numeric',\n          meridiem: 'short'\n        };\n      }\n\n      break;\n\n    case 'second':\n      // sufficiently large number of different second cells?\n      if (asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30 PM'\n\n        format1 = function format1(params) {\n          return ':' + padStart(params.date.second, 2) // ':30'\n          ;\n        };\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          second: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30:45 PM'\n      }\n\n      break;\n\n    case 'millisecond':\n      format0 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        second: '2-digit',\n        meridiem: 'lowercase'\n      }; // '8:30:45 PM'\n\n      format1 = function format1(params) {\n        return '.' + padStart(params.millisecond, 3);\n      };\n\n      break;\n  }\n\n  return [].concat(format0 || [], format1 || [], format2 || []);\n} // Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\n\n\nfunction currentRangeAs(unit, dateProfile, dateEnv) {\n  var range = dateProfile.currentRange;\n  var res = null;\n\n  if (unit === 'years') {\n    res = dateEnv.diffWholeYears(range.start, range.end);\n  } else if (unit === 'months') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'weeks') {\n    res = dateEnv.diffWholeMonths(range.start, range.end);\n  } else if (unit === 'days') {\n    res = diffWholeDays(range.start, range.end);\n  }\n\n  return res || 0;\n}\n\nfunction buildIsWeekStarts(tDateProfile, dateEnv) {\n  var slotDates = tDateProfile.slotDates,\n      emphasizeWeeks = tDateProfile.emphasizeWeeks;\n  var prevWeekNumber = null;\n  var isWeekStarts = [];\n\n  for (var _i = 0, slotDates_1 = slotDates; _i < slotDates_1.length; _i++) {\n    var slotDate = slotDates_1[_i];\n    var weekNumber = dateEnv.computeWeekNumber(slotDate);\n    var isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;\n    prevWeekNumber = weekNumber;\n    isWeekStarts.push(isWeekStart);\n  }\n\n  return isWeekStarts;\n}\n\nfunction buildCellRows(tDateProfile, dateEnv) {\n  var slotDates = tDateProfile.slotDates;\n  var formats = tDateProfile.headerFormats;\n  var cellRows = formats.map(function () {\n    return [];\n  }); // indexed by row,col\n\n  var slotAsDays = asCleanDays(tDateProfile.slotDuration);\n  var guessedSlotUnit = slotAsDays === 7 ? 'week' : slotAsDays === 1 ? 'day' : null; // specifically for navclicks\n\n  var rowUnitsFromFormats = formats.map(function (format) {\n    return format.getLargestUnit ? format.getLargestUnit() : null;\n  }); // builds cellRows and slotCells\n\n  for (var i = 0; i < slotDates.length; i += 1) {\n    var date = slotDates[i];\n    var isWeekStart = tDateProfile.isWeekStarts[i];\n\n    for (var row = 0; row < formats.length; row += 1) {\n      var format = formats[row];\n      var rowCells = cellRows[row];\n      var leadingCell = rowCells[rowCells.length - 1];\n      var isLastRow = row === formats.length - 1;\n      var isSuperRow = formats.length > 1 && !isLastRow; // more than one row and not the last\n\n      var newCell = null;\n      var rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null);\n\n      if (isSuperRow) {\n        var text = dateEnv.format(date, format);\n\n        if (!leadingCell || leadingCell.text !== text) {\n          newCell = buildCellObject(date, text, rowUnit);\n        } else {\n          leadingCell.colspan += 1;\n        }\n      } else if (!leadingCell || isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n        var text = dateEnv.format(date, format);\n        newCell = buildCellObject(date, text, rowUnit);\n      } else {\n        leadingCell.colspan += 1;\n      }\n\n      if (newCell) {\n        newCell.weekStart = isWeekStart;\n        rowCells.push(newCell);\n      }\n    }\n  }\n\n  return cellRows;\n}\n\nfunction buildCellObject(date, text, rowUnit) {\n  return {\n    date: date,\n    text: text,\n    rowUnit: rowUnit,\n    colspan: 1,\n    isWeekStart: false\n  };\n}\n\nvar TimelineHeaderThInner =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeaderThInner, _super);\n\n  function TimelineHeaderThInner() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineHeaderThInner.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return createElement(ContentHook, {\n      hookProps: props.hookProps,\n      content: context.options.slotLabelContent,\n      defaultContent: renderInnerContent\n    }, function (innerElRef, innerContent) {\n      return createElement(\"a\", __assign({\n        ref: innerElRef,\n        className: 'fc-timeline-slot-cushion fc-scrollgrid-sync-inner' + (props.isSticky ? ' fc-sticky' : '')\n      }, props.navLinkAttrs), innerContent);\n    });\n  };\n\n  return TimelineHeaderThInner;\n}(BaseComponent);\n\nfunction renderInnerContent(props) {\n  return props.text;\n}\n\nfunction refineHookProps(input) {\n  return {\n    level: input.level,\n    date: input.dateEnv.toDate(input.dateMarker),\n    view: input.viewApi,\n    text: input.text\n  };\n}\n\nvar TimelineHeaderTh =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeaderTh, _super);\n\n  function TimelineHeaderTh() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.refineHookProps = memoizeObjArg(refineHookProps);\n    _this.normalizeClassNames = buildClassNameNormalizer();\n    _this.buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs);\n    return _this;\n  }\n\n  TimelineHeaderTh.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateEnv = context.dateEnv,\n        options = context.options;\n    var cell = props.cell,\n        dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile; // the cell.rowUnit is f'd\n    // giving 'month' for a 3-day view\n    // workaround: to infer day, do NOT time\n\n    var dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile);\n    var classNames = ['fc-timeline-slot', 'fc-timeline-slot-label'].concat(cell.rowUnit === 'time' // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n    ? getSlotClassNames(dateMeta, context.theme) : getDayClassNames(dateMeta, context.theme));\n\n    if (cell.isWeekStart) {\n      classNames.push('fc-timeline-slot-em');\n    }\n\n    var hookProps = this.refineHookProps({\n      level: props.rowLevel,\n      dateMarker: cell.date,\n      text: cell.text,\n      dateEnv: context.dateEnv,\n      viewApi: context.viewApi\n    });\n    var customClassNames = this.normalizeClassNames(options.slotLabelClassNames, hookProps);\n    return createElement(MountHook, {\n      hookProps: hookProps,\n      didMount: options.slotLabelDidMount,\n      willUnmount: options.slotLabelWillUnmount\n    }, function (rootElRef) {\n      return createElement(\"th\", {\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' '),\n        \"data-date\": dateEnv.formatIso(cell.date, {\n          omitTime: !tDateProfile.isTimeScale,\n          omitTimeZoneOffset: true\n        }),\n        colSpan: cell.colspan\n      }, createElement(\"div\", {\n        className: \"fc-timeline-slot-frame\",\n        style: {\n          height: props.rowInnerHeight\n        }\n      }, createElement(TimelineHeaderThInner, {\n        hookProps: hookProps,\n        isSticky: props.isSticky,\n        navLinkAttrs: _this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)\n      })));\n    });\n  };\n\n  return TimelineHeaderTh;\n}(BaseComponent);\n\nfunction buildCellNavLinkAttrs(context, cellDate, rowUnit) {\n  return rowUnit && rowUnit !== 'time' ? buildNavLinkAttrs(context, cellDate, rowUnit) : {};\n}\n\nvar TimelineHeaderRows =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeaderRows, _super);\n\n  function TimelineHeaderRows() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineHeaderRows.prototype.render = function () {\n    var _a = this.props,\n        dateProfile = _a.dateProfile,\n        tDateProfile = _a.tDateProfile,\n        rowInnerHeights = _a.rowInnerHeights,\n        todayRange = _a.todayRange,\n        nowDate = _a.nowDate;\n    var cellRows = tDateProfile.cellRows;\n    return createElement(Fragment, null, cellRows.map(function (rowCells, rowLevel) {\n      var isLast = rowLevel === cellRows.length - 1;\n      var isChrono = tDateProfile.isTimeScale && isLast; // the final row, with times?\n\n      var classNames = ['fc-timeline-header-row', isChrono ? 'fc-timeline-header-row-chrono' : ''];\n      return (// eslint-disable-next-line react/no-array-index-key\n        createElement(\"tr\", {\n          key: rowLevel,\n          className: classNames.join(' ')\n        }, rowCells.map(function (cell) {\n          return createElement(TimelineHeaderTh, {\n            key: cell.date.toISOString(),\n            cell: cell,\n            rowLevel: rowLevel,\n            dateProfile: dateProfile,\n            tDateProfile: tDateProfile,\n            todayRange: todayRange,\n            nowDate: nowDate,\n            rowInnerHeight: rowInnerHeights && rowInnerHeights[rowLevel],\n            isSticky: !isLast\n          });\n        }))\n      );\n    }));\n  };\n\n  return TimelineHeaderRows;\n}(BaseComponent);\n\nvar TimelineCoords =\n/** @class */\nfunction () {\n  function TimelineCoords(slatRootEl, // okay to expose?\n  slatEls, dateProfile, tDateProfile, dateEnv, isRtl) {\n    this.slatRootEl = slatRootEl;\n    this.dateProfile = dateProfile;\n    this.tDateProfile = tDateProfile;\n    this.dateEnv = dateEnv;\n    this.isRtl = isRtl;\n    this.outerCoordCache = new PositionCache(slatRootEl, slatEls, true, // isHorizontal\n    false); // for the inner divs within the slats\n    // used for event rendering and scrollTime, to disregard slat border\n\n    this.innerCoordCache = new PositionCache(slatRootEl, findDirectChildren(slatEls, 'div'), true, // isHorizontal\n    false);\n  }\n\n  TimelineCoords.prototype.isDateInRange = function (date) {\n    return rangeContainsMarker(this.dateProfile.currentRange, date);\n  }; // results range from negative width of area to 0\n\n\n  TimelineCoords.prototype.dateToCoord = function (date) {\n    var tDateProfile = this.tDateProfile;\n    var snapCoverage = this.computeDateSnapCoverage(date);\n    var slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n    var slotIndex = Math.floor(slotCoverage);\n    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n    var partial = slotCoverage - slotIndex;\n\n    var _a = this,\n        innerCoordCache = _a.innerCoordCache,\n        outerCoordCache = _a.outerCoordCache;\n\n    if (this.isRtl) {\n      return outerCoordCache.originClientRect.width - (outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial);\n    }\n\n    return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;\n  };\n\n  TimelineCoords.prototype.rangeToCoords = function (range) {\n    return {\n      start: this.dateToCoord(range.start),\n      end: this.dateToCoord(range.end)\n    };\n  };\n\n  TimelineCoords.prototype.durationToCoord = function (duration) {\n    var _a = this,\n        dateProfile = _a.dateProfile,\n        tDateProfile = _a.tDateProfile,\n        dateEnv = _a.dateEnv,\n        isRtl = _a.isRtl;\n\n    var coord = 0;\n\n    if (dateProfile) {\n      var date = dateEnv.add(dateProfile.activeRange.start, duration);\n\n      if (!tDateProfile.isTimeScale) {\n        date = startOfDay(date);\n      }\n\n      coord = this.dateToCoord(date); // hack to overcome the left borders of non-first slat\n\n      if (!isRtl && coord) {\n        coord += 1;\n      }\n    }\n\n    return coord;\n  };\n\n  TimelineCoords.prototype.coordFromLeft = function (coord) {\n    if (this.isRtl) {\n      return this.outerCoordCache.originClientRect.width - coord;\n    }\n\n    return coord;\n  }; // returned value is between 0 and the number of snaps\n\n\n  TimelineCoords.prototype.computeDateSnapCoverage = function (date) {\n    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv);\n  };\n\n  return TimelineCoords;\n}(); // returned value is between 0 and the number of snaps\n\n\nfunction computeDateSnapCoverage(date, tDateProfile, dateEnv) {\n  var snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n\n  if (snapDiff < 0) {\n    return 0;\n  }\n\n  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n    return tDateProfile.snapCnt;\n  }\n\n  var snapDiffInt = Math.floor(snapDiff);\n  var snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n\n  if (isInt(snapCoverage)) {\n    // not an in-between value\n    snapCoverage += snapDiff - snapDiffInt; // add the remainder\n  } else {\n    // a fractional value, meaning the date is not visible\n    // always round up in this case. works for start AND end dates in a range.\n    snapCoverage = Math.ceil(snapCoverage);\n  }\n\n  return snapCoverage;\n}\n\nfunction coordToCss(hcoord, isRtl) {\n  if (hcoord === null) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n\n  if (isRtl) {\n    return {\n      right: hcoord,\n      left: ''\n    };\n  }\n\n  return {\n    left: hcoord,\n    right: ''\n  };\n}\n\nfunction coordsToCss(hcoords, isRtl) {\n  if (!hcoords) {\n    return {\n      left: '',\n      right: ''\n    };\n  }\n\n  if (isRtl) {\n    return {\n      right: hcoords.start,\n      left: -hcoords.end\n    };\n  }\n\n  return {\n    left: hcoords.start,\n    right: -hcoords.end\n  };\n}\n\nvar TimelineHeader =\n/** @class */\nfunction (_super) {\n  __extends(TimelineHeader, _super);\n\n  function TimelineHeader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    return _this;\n  }\n\n  TimelineHeader.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context; // TODO: very repetitive\n    // TODO: make part of tDateProfile?\n\n\n    var timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit; // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n\n    var slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null;\n    return createElement(NowTimer, {\n      unit: timerUnit\n    }, function (nowDate, todayRange) {\n      return createElement(\"div\", {\n        className: \"fc-timeline-header\",\n        ref: _this.rootElRef\n      }, createElement(\"table\", {\n        \"aria-hidden\": true,\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          minWidth: props.tableMinWidth,\n          width: props.clientWidth\n        }\n      }, props.tableColGroupNode, createElement(\"tbody\", null, createElement(TimelineHeaderRows, {\n        dateProfile: props.dateProfile,\n        tDateProfile: props.tDateProfile,\n        nowDate: nowDate,\n        todayRange: todayRange,\n        rowInnerHeights: props.rowInnerHeights\n      }))), context.options.nowIndicator && // need to have a container regardless of whether the current view has a visible now indicator\n      // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n      // this issue doesn't happen for the timeline body however (\n      createElement(\"div\", {\n        className: \"fc-timeline-now-indicator-container\"\n      }, slatCoords && slatCoords.isDateInRange(nowDate) && createElement(NowIndicatorRoot, {\n        isAxis: true,\n        date: nowDate\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timeline-now-indicator-arrow'].concat(classNames).join(' '),\n          style: coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl)\n        }, innerContent);\n      })));\n    });\n  };\n\n  TimelineHeader.prototype.componentDidMount = function () {\n    this.updateSize();\n  };\n\n  TimelineHeader.prototype.componentDidUpdate = function () {\n    this.updateSize();\n  };\n\n  TimelineHeader.prototype.updateSize = function () {\n    if (this.props.onMaxCushionWidth) {\n      this.props.onMaxCushionWidth(this.computeMaxCushionWidth());\n    }\n  };\n\n  TimelineHeader.prototype.computeMaxCushionWidth = function () {\n    return Math.max.apply(Math, findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(function (el) {\n      return el.getBoundingClientRect().width;\n    }));\n  };\n\n  return TimelineHeader;\n}(BaseComponent);\n\nvar TimelineSlatCell =\n/** @class */\nfunction (_super) {\n  __extends(TimelineSlatCell, _super);\n\n  function TimelineSlatCell() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineSlatCell.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var dateEnv = context.dateEnv,\n        options = context.options,\n        theme = context.theme;\n    var date = props.date,\n        tDateProfile = props.tDateProfile,\n        isEm = props.isEm;\n    var dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile);\n    var classNames = ['fc-timeline-slot', 'fc-timeline-slot-lane'];\n    var dataAttrs = {\n      'data-date': dateEnv.formatIso(date, {\n        omitTimeZoneOffset: true,\n        omitTime: !tDateProfile.isTimeScale\n      })\n    };\n\n    var hookProps = __assign(__assign({\n      date: dateEnv.toDate(props.date)\n    }, dateMeta), {\n      view: context.viewApi\n    });\n\n    if (isEm) {\n      classNames.push('fc-timeline-slot-em');\n    }\n\n    if (tDateProfile.isTimeScale) {\n      classNames.push(isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, props.date, tDateProfile.labelInterval)) ? 'fc-timeline-slot-major' : 'fc-timeline-slot-minor');\n    }\n\n    classNames.push.apply(classNames, props.isDay ? getDayClassNames(dateMeta, theme) : getSlotClassNames(dateMeta, theme));\n    return createElement(RenderHook, {\n      hookProps: hookProps,\n      classNames: options.slotLaneClassNames,\n      content: options.slotLaneContent,\n      didMount: options.slotLaneDidMount,\n      willUnmount: options.slotLaneWillUnmount,\n      elRef: props.elRef\n    }, function (rootElRef, customClassNames, innerElRef, innerContent) {\n      return createElement(\"td\", __assign({\n        ref: rootElRef,\n        className: classNames.concat(customClassNames).join(' ')\n      }, dataAttrs), createElement(\"div\", {\n        ref: innerElRef\n      }, innerContent));\n    });\n  };\n\n  return TimelineSlatCell;\n}(BaseComponent);\n\nvar TimelineSlatsBody =\n/** @class */\nfunction (_super) {\n  __extends(TimelineSlatsBody, _super);\n\n  function TimelineSlatsBody() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineSlatsBody.prototype.render = function () {\n    var props = this.props;\n    var tDateProfile = props.tDateProfile,\n        cellElRefs = props.cellElRefs;\n    var slotDates = tDateProfile.slotDates,\n        isWeekStarts = tDateProfile.isWeekStarts;\n    var isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit;\n    return createElement(\"tbody\", null, createElement(\"tr\", null, slotDates.map(function (slotDate, i) {\n      var key = slotDate.toISOString();\n      return createElement(TimelineSlatCell, {\n        key: key,\n        elRef: cellElRefs.createRef(key),\n        date: slotDate,\n        dateProfile: props.dateProfile,\n        tDateProfile: tDateProfile,\n        nowDate: props.nowDate,\n        todayRange: props.todayRange,\n        isEm: isWeekStarts[i],\n        isDay: isDay\n      });\n    })));\n  };\n\n  return TimelineSlatsBody;\n}(BaseComponent);\n\nvar TimelineSlats =\n/** @class */\nfunction (_super) {\n  __extends(TimelineSlats, _super);\n\n  function TimelineSlats() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    _this.cellElRefs = new RefMap();\n\n    _this.handleScrollRequest = function (request) {\n      var onScrollLeftRequest = _this.props.onScrollLeftRequest;\n      var coords = _this.coords;\n\n      if (onScrollLeftRequest && coords) {\n        if (request.time) {\n          var scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time));\n          onScrollLeftRequest(scrollLeft);\n        }\n\n        return true;\n      }\n\n      return null; // best?\n    };\n\n    return _this;\n  }\n\n  TimelineSlats.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return createElement(\"div\", {\n      className: \"fc-timeline-slots\",\n      ref: this.rootElRef\n    }, createElement(\"table\", {\n      \"aria-hidden\": true,\n      className: context.theme.getClass('table'),\n      style: {\n        minWidth: props.tableMinWidth,\n        width: props.clientWidth\n      }\n    }, props.tableColGroupNode, createElement(TimelineSlatsBody, {\n      cellElRefs: this.cellElRefs,\n      dateProfile: props.dateProfile,\n      tDateProfile: props.tDateProfile,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange\n    })));\n  };\n\n  TimelineSlats.prototype.componentDidMount = function () {\n    this.updateSizing();\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n  };\n\n  TimelineSlats.prototype.componentDidUpdate = function (prevProps) {\n    this.updateSizing();\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n  };\n\n  TimelineSlats.prototype.componentWillUnmount = function () {\n    this.scrollResponder.detach();\n\n    if (this.props.onCoords) {\n      this.props.onCoords(null);\n    }\n  };\n\n  TimelineSlats.prototype.updateSizing = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    if (props.clientWidth !== null && // is sizing stable?\n    this.scrollResponder // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n    ) {\n      var rootEl = this.rootElRef.current;\n\n      if (rootEl.offsetWidth) {\n        // not hidden by css\n        this.coords = new TimelineCoords(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates), props.dateProfile, props.tDateProfile, context.dateEnv, context.isRtl);\n\n        if (props.onCoords) {\n          props.onCoords(this.coords);\n        }\n\n        this.scrollResponder.update(false); // TODO: wouldn't have to do this if coords were in state\n      }\n    }\n  };\n\n  TimelineSlats.prototype.positionToHit = function (leftPosition) {\n    var outerCoordCache = this.coords.outerCoordCache;\n    var _a = this.context,\n        dateEnv = _a.dateEnv,\n        isRtl = _a.isRtl;\n    var tDateProfile = this.props.tDateProfile;\n    var slatIndex = outerCoordCache.leftToIndex(leftPosition);\n\n    if (slatIndex != null) {\n      // somewhat similar to what TimeGrid does. consolidate?\n      var slatWidth = outerCoordCache.getWidth(slatIndex);\n      var partial = isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n      var localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n      var start = dateEnv.add(tDateProfile.slotDates[slatIndex], multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n      var end = dateEnv.add(start, tDateProfile.snapDuration);\n      return {\n        dateSpan: {\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: !this.props.tDateProfile.isTimeScale\n        },\n        dayEl: this.cellElRefs.currentMap[slatIndex],\n        left: outerCoordCache.lefts[slatIndex],\n        right: outerCoordCache.rights[slatIndex]\n      };\n    }\n\n    return null;\n  };\n\n  return TimelineSlats;\n}(BaseComponent);\n\nfunction collectCellEls(elMap, slotDates) {\n  return slotDates.map(function (slotDate) {\n    var key = slotDate.toISOString();\n    return elMap[key];\n  });\n}\n\nfunction computeSegHCoords(segs, minWidth, timelineCoords) {\n  var hcoords = [];\n\n  if (timelineCoords) {\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      var res = timelineCoords.rangeToCoords(seg);\n      var start = Math.round(res.start); // for barely-overlapping collisions\n\n      var end = Math.round(res.end); //\n\n      if (end - start < minWidth) {\n        end = start + minWidth;\n      }\n\n      hcoords.push({\n        start: start,\n        end: end\n      });\n    }\n  }\n\n  return hcoords;\n}\n\nfunction computeFgSegPlacements(segs, segHCoords, // might not have for every seg\neventInstanceHeights, // might not have for every seg\nmoreLinkHeights, // might not have for every more-link\nstrictOrder, maxStackCnt) {\n  var segInputs = [];\n  var crudePlacements = []; // when we don't know dims\n\n  for (var i = 0; i < segs.length; i += 1) {\n    var seg = segs[i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var height = eventInstanceHeights[instanceId];\n    var hcoords = segHCoords[i];\n\n    if (height && hcoords) {\n      segInputs.push({\n        index: i,\n        span: hcoords,\n        thickness: height\n      });\n    } else {\n      crudePlacements.push({\n        seg: seg,\n        hcoords: hcoords,\n        top: null\n      });\n    }\n  }\n\n  var hierarchy = new SegHierarchy();\n\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder;\n  }\n\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt;\n  }\n\n  var hiddenEntries = hierarchy.addSegs(segInputs);\n  var hiddenPlacements = hiddenEntries.map(function (entry) {\n    return {\n      seg: segs[entry.index],\n      hcoords: entry.span,\n      top: null\n    };\n  });\n  var hiddenGroups = groupIntersectingEntries(hiddenEntries);\n  var moreLinkInputs = [];\n  var moreLinkCrudePlacements = [];\n\n  var extractSeg = function extractSeg(entry) {\n    return segs[entry.index];\n  };\n\n  for (var i = 0; i < hiddenGroups.length; i += 1) {\n    var hiddenGroup = hiddenGroups[i];\n    var sortedSegs = hiddenGroup.entries.map(extractSeg);\n    var height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))]; // not optimal :(\n\n    if (height != null) {\n      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n      moreLinkInputs.push({\n        index: segs.length + i,\n        thickness: height,\n        span: hiddenGroup.span\n      });\n    } else {\n      moreLinkCrudePlacements.push({\n        seg: sortedSegs,\n        hcoords: hiddenGroup.span,\n        top: null\n      });\n    }\n  } // add more-links into the hierarchy, but don't limit\n\n\n  hierarchy.maxStackCnt = -1;\n  hierarchy.addSegs(moreLinkInputs);\n  var visibleRects = hierarchy.toRects();\n  var visiblePlacements = [];\n  var maxHeight = 0;\n\n  for (var _i = 0, visibleRects_1 = visibleRects; _i < visibleRects_1.length; _i++) {\n    var rect = visibleRects_1[_i];\n    var segIndex = rect.index;\n    visiblePlacements.push({\n      seg: segIndex < segs.length ? segs[segIndex] // a real seg\n      : hiddenGroups[segIndex - segs.length].entries.map(extractSeg),\n      hcoords: rect.span,\n      top: rect.levelCoord\n    });\n    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness);\n  }\n\n  return [visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements), maxHeight];\n}\n\nvar TimelineLaneBg =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLaneBg, _super);\n\n  function TimelineLaneBg() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineLaneBg.prototype.render = function () {\n    var props = this.props;\n    var highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs);\n    return props.timelineCoords && createElement(\"div\", {\n      className: \"fc-timeline-bg\"\n    }, this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business'), this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event'), this.renderSegs(highlightSeg, props.timelineCoords, 'highlight'));\n  };\n\n  TimelineLaneBg.prototype.renderSegs = function (segs, timelineCoords, fillType) {\n    var _a = this.props,\n        todayRange = _a.todayRange,\n        nowDate = _a.nowDate;\n    var isRtl = this.context.isRtl;\n    var segHCoords = computeSegHCoords(segs, 0, timelineCoords);\n    var children = segs.map(function (seg, i) {\n      var hcoords = segHCoords[i];\n      var hStyle = coordsToCss(hcoords, isRtl);\n      return createElement(\"div\", {\n        key: buildEventRangeKey(seg.eventRange),\n        className: \"fc-timeline-bg-harness\",\n        style: hStyle\n      }, fillType === 'bg-event' ? createElement(BgEvent, __assign({\n        seg: seg\n      }, getSegMeta(seg, todayRange, nowDate))) : renderFill(fillType));\n    });\n    return createElement(Fragment, null, children);\n  };\n\n  return TimelineLaneBg;\n}(BaseComponent);\n\nvar TimelineLaneSlicer =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLaneSlicer, _super);\n\n  function TimelineLaneSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineLaneSlicer.prototype.sliceRange = function (origRange, dateProfile, dateProfileGenerator, tDateProfile, dateEnv) {\n    var normalRange = normalizeRange(origRange, tDateProfile, dateEnv);\n    var segs = []; // protect against when the span is entirely in an invalid date region\n\n    if (computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv) < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)) {\n      // intersect the footprint's range with the grid's range\n      var slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange);\n\n      if (slicedRange) {\n        segs.push({\n          start: slicedRange.start,\n          end: slicedRange.end,\n          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator)\n        });\n      }\n    }\n\n    return segs;\n  };\n\n  return TimelineLaneSlicer;\n}(Slicer);\n\nvar DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nvar TimelineEvent =\n/** @class */\nfunction (_super) {\n  __extends(TimelineEvent, _super);\n\n  function TimelineEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimelineEvent.prototype.render = function () {\n    var props = this.props;\n    return createElement(StandardEvent, __assign({}, props, {\n      extraClassNames: ['fc-timeline-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TIME_FORMAT,\n      defaultDisplayEventTime: !props.isTimeScale\n    }));\n  };\n\n  return TimelineEvent;\n}(BaseComponent);\n\nvar TimelineLaneMoreLink =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLaneMoreLink, _super);\n\n  function TimelineLaneMoreLink() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    return _this;\n  }\n\n  TimelineLaneMoreLink.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var hiddenSegs = props.hiddenSegs,\n        elRef = props.elRef,\n        placement = props.placement,\n        resourceId = props.resourceId;\n    var top = placement.top,\n        hcoords = placement.hcoords;\n    var isVisible = hcoords && top !== null;\n    var hStyle = coordsToCss(hcoords, context.isRtl);\n    var extraDateSpan = resourceId ? {\n      resourceId: resourceId\n    } : {};\n    return createElement(MoreLinkRoot, {\n      allDayDate: null,\n      moreCnt: hiddenSegs.length,\n      allSegs: hiddenSegs,\n      hiddenSegs: hiddenSegs,\n      alignmentElRef: this.rootElRef,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      extraDateSpan: extraDateSpan,\n      popoverContent: function popoverContent() {\n        return createElement(Fragment, null, hiddenSegs.map(function (seg) {\n          var instanceId = seg.eventRange.instance.instanceId;\n          return createElement(\"div\", {\n            key: instanceId,\n            style: {\n              visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ''\n            }\n          }, createElement(TimelineEvent, __assign({\n            isTimeScale: props.isTimeScale,\n            seg: seg,\n            isDragging: false,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: instanceId === props.eventSelection\n          }, getSegMeta(seg, props.todayRange, props.nowDate))));\n        }));\n      }\n    }, function (rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n      return createElement(\"a\", {\n        ref: function ref(el) {\n          setRef(rootElRef, el); // for MoreLinkRoot\n\n          setRef(elRef, el); // for props props\n\n          setRef(_this.rootElRef, el); // for this component\n        },\n        className: ['fc-timeline-more-link'].concat(classNames).join(' '),\n        style: __assign({\n          visibility: isVisible ? '' : 'hidden',\n          top: top || 0\n        }, hStyle),\n        onClick: handleClick,\n        title: title,\n        \"aria-expanded\": isExpanded,\n        \"aria-controls\": popoverId\n      }, createElement(\"div\", {\n        ref: innerElRef,\n        className: \"fc-timeline-more-link-inner fc-sticky\"\n      }, innerContent));\n    });\n  };\n\n  return TimelineLaneMoreLink;\n}(BaseComponent);\n\nvar TimelineLane =\n/** @class */\nfunction (_super) {\n  __extends(TimelineLane, _super);\n\n  function TimelineLane() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new TimelineLaneSlicer();\n    _this.sortEventSegs = memoize(sortEventSegs);\n    _this.harnessElRefs = new RefMap();\n    _this.moreElRefs = new RefMap();\n    _this.innerElRef = createRef(); // TODO: memoize event positioning\n\n    _this.state = {\n      eventInstanceHeights: {},\n      moreLinkHeights: {}\n    };\n    return _this;\n  }\n\n  TimelineLane.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n    var slicedProps = this.slicer.sliceProps(props, dateProfile, tDateProfile.isTimeScale ? null : props.nextDayThreshold, context, // wish we didn't have to pass in the rest of the args...\n    dateProfile, context.dateProfileGenerator, tDateProfile, context.dateEnv);\n    var mirrorSegs = (slicedProps.eventDrag ? slicedProps.eventDrag.segs : null) || (slicedProps.eventResize ? slicedProps.eventResize.segs : null) || [];\n    var fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder);\n    var fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords);\n\n    var _b = computeFgSegPlacements(fgSegs, fgSegHCoords, state.eventInstanceHeights, state.moreLinkHeights, options.eventOrderStrict, options.eventMaxStack),\n        fgPlacements = _b[0],\n        fgHeight = _b[1];\n\n    var isForcedInvisible = // TODO: more convenient\n    (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) || (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) || {};\n    return createElement(Fragment, null, createElement(TimelineLaneBg, {\n      businessHourSegs: slicedProps.businessHourSegs,\n      bgEventSegs: slicedProps.bgEventSegs,\n      timelineCoords: props.timelineCoords,\n      eventResizeSegs: slicedProps.eventResize ? slicedProps.eventResize.segs : []\n      /* bad new empty array? */\n      ,\n      dateSelectionSegs: slicedProps.dateSelectionSegs,\n      nowDate: props.nowDate,\n      todayRange: props.todayRange\n    }), createElement(\"div\", {\n      className: \"fc-timeline-events fc-scrollgrid-sync-inner\",\n      ref: this.innerElRef,\n      style: {\n        height: fgHeight\n      }\n    }, this.renderFgSegs(fgPlacements, isForcedInvisible, false, false, false), this.renderFgSegs(buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements), {}, Boolean(slicedProps.eventDrag), Boolean(slicedProps.eventResize), false)));\n  };\n\n  TimelineLane.prototype.componentDidMount = function () {\n    this.updateSize();\n  };\n\n  TimelineLane.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevProps.eventStore !== this.props.eventStore || // external thing changed?\n    prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n    prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n    ) {\n      this.updateSize();\n    }\n  };\n\n  TimelineLane.prototype.updateSize = function () {\n    var _this = this;\n\n    var props = this.props;\n    var timelineCoords = props.timelineCoords;\n\n    if (props.onHeightChange) {\n      props.onHeightChange(this.innerElRef.current, false);\n    }\n\n    if (timelineCoords) {\n      this.setState({\n        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, function (harnessEl) {\n          return Math.round(harnessEl.getBoundingClientRect().height);\n        }),\n        moreLinkHeights: mapHash(this.moreElRefs.currentMap, function (moreEl) {\n          return Math.round(moreEl.getBoundingClientRect().height);\n        })\n      }, function () {\n        if (props.onHeightChange) {\n          props.onHeightChange(_this.innerElRef.current, true);\n        }\n      });\n    }\n  };\n\n  TimelineLane.prototype.renderFgSegs = function (segPlacements, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n    var _a = this,\n        harnessElRefs = _a.harnessElRefs,\n        moreElRefs = _a.moreElRefs,\n        props = _a.props,\n        context = _a.context;\n\n    var isMirror = isDragging || isResizing || isDateSelecting;\n    return createElement(Fragment, null, segPlacements.map(function (segPlacement) {\n      var seg = segPlacement.seg,\n          hcoords = segPlacement.hcoords,\n          top = segPlacement.top;\n\n      if (Array.isArray(seg)) {\n        // a more-link\n        var isoStr = buildIsoString(computeEarliestSegStart(seg));\n        return createElement(TimelineLaneMoreLink, {\n          key: 'm:' + isoStr\n          /* \"m\" for \"more\" */\n          ,\n          elRef: moreElRefs.createRef(isoStr),\n          hiddenSegs: seg,\n          placement: segPlacement,\n          dateProfile: props.dateProfile,\n          nowDate: props.nowDate,\n          todayRange: props.todayRange,\n          isTimeScale: props.tDateProfile.isTimeScale,\n          eventSelection: props.eventSelection,\n          resourceId: props.resourceId,\n          isForcedInvisible: isForcedInvisible\n        });\n      }\n\n      var instanceId = seg.eventRange.instance.instanceId;\n      var isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null);\n      var hStyle = coordsToCss(hcoords, context.isRtl);\n      return createElement(\"div\", {\n        key: 'e:' + instanceId\n        /* \"e\" for \"event\" */\n        ,\n        ref: isMirror ? null : harnessElRefs.createRef(instanceId),\n        className: \"fc-timeline-event-harness\",\n        style: __assign({\n          visibility: isVisible ? '' : 'hidden',\n          top: top || 0\n        }, hStyle)\n      }, createElement(TimelineEvent, __assign({\n        isTimeScale: props.tDateProfile.isTimeScale,\n        seg: seg,\n        isDragging: isDragging,\n        isResizing: isResizing,\n        isDateSelecting: isDateSelecting,\n        isSelected: instanceId === props.eventSelection\n        /* TODO: bad for mirror? */\n\n      }, getSegMeta(seg, props.todayRange, props.nowDate))));\n    }));\n  };\n\n  return TimelineLane;\n}(BaseComponent);\n\nTimelineLane.addStateEquality({\n  eventInstanceHeights: isPropsEqual,\n  moreLinkHeights: isPropsEqual\n});\n\nfunction buildMirrorPlacements(mirrorSegs, timelineCoords, fgPlacements) {\n  if (!mirrorSegs.length || !timelineCoords) {\n    return [];\n  }\n\n  var topsByInstanceId = buildAbsoluteTopHash(fgPlacements); // TODO: cache this at first render?\n\n  return mirrorSegs.map(function (seg) {\n    return {\n      seg: seg,\n      hcoords: timelineCoords.rangeToCoords(seg),\n      top: topsByInstanceId[seg.eventRange.instance.instanceId]\n    };\n  });\n}\n\nfunction buildAbsoluteTopHash(placements) {\n  var topsByInstanceId = {};\n\n  for (var _i = 0, placements_1 = placements; _i < placements_1.length; _i++) {\n    var placement = placements_1[_i];\n    var seg = placement.seg;\n\n    if (!Array.isArray(seg)) {\n      // doesn't represent a more-link\n      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top;\n    }\n  }\n\n  return topsByInstanceId;\n}\n\nvar TimelineGrid =\n/** @class */\nfunction (_super) {\n  __extends(TimelineGrid, _super);\n\n  function TimelineGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slatsRef = createRef();\n    _this.state = {\n      coords: null\n    };\n\n    _this.handeEl = function (el) {\n      if (el) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: el\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    _this.handleCoords = function (coords) {\n      _this.setState({\n        coords: coords\n      });\n\n      if (_this.props.onSlatCoords) {\n        _this.props.onSlatCoords(coords);\n      }\n    };\n\n    return _this;\n  }\n\n  TimelineGrid.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var dateProfile = props.dateProfile,\n        tDateProfile = props.tDateProfile;\n    var timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit;\n    return createElement(\"div\", {\n      className: \"fc-timeline-body\",\n      ref: this.handeEl,\n      style: {\n        minWidth: props.tableMinWidth,\n        height: props.clientHeight,\n        width: props.clientWidth\n      }\n    }, createElement(NowTimer, {\n      unit: timerUnit\n    }, function (nowDate, todayRange) {\n      return createElement(Fragment, null, createElement(TimelineSlats, {\n        ref: _this.slatsRef,\n        dateProfile: dateProfile,\n        tDateProfile: tDateProfile,\n        nowDate: nowDate,\n        todayRange: todayRange,\n        clientWidth: props.clientWidth,\n        tableColGroupNode: props.tableColGroupNode,\n        tableMinWidth: props.tableMinWidth,\n        onCoords: _this.handleCoords,\n        onScrollLeftRequest: props.onScrollLeftRequest\n      }), createElement(TimelineLane, {\n        dateProfile: dateProfile,\n        tDateProfile: props.tDateProfile,\n        nowDate: nowDate,\n        todayRange: todayRange,\n        nextDayThreshold: options.nextDayThreshold,\n        businessHours: props.businessHours,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        dateSelection: props.dateSelection,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        timelineCoords: state.coords\n      }), options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate) && createElement(\"div\", {\n        className: \"fc-timeline-now-indicator-container\"\n      }, createElement(NowIndicatorRoot, {\n        isAxis: false,\n        date: nowDate\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"div\", {\n          ref: rootElRef,\n          className: ['fc-timeline-now-indicator-line'].concat(classNames).join(' '),\n          style: coordToCss(state.coords.dateToCoord(nowDate), context.isRtl)\n        }, innerContent);\n      })));\n    }));\n  }; // Hit System\n  // ------------------------------------------------------------------------------------------\n\n\n  TimelineGrid.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n    var slats = this.slatsRef.current;\n    var slatHit = slats.positionToHit(positionLeft);\n\n    if (slatHit) {\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: slatHit.dateSpan,\n        rect: {\n          left: slatHit.left,\n          right: slatHit.right,\n          top: 0,\n          bottom: elHeight\n        },\n        dayEl: slatHit.dayEl,\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  return TimelineGrid;\n}(DateComponent);\n\nvar TimelineView =\n/** @class */\nfunction (_super) {\n  __extends(TimelineView, _super);\n\n  function TimelineView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildTimelineDateProfile = memoize(buildTimelineDateProfile);\n    _this.scrollGridRef = createRef();\n    _this.state = {\n      slatCoords: null,\n      slotCushionMaxWidth: null\n    };\n\n    _this.handleSlatCoords = function (slatCoords) {\n      _this.setState({\n        slatCoords: slatCoords\n      });\n    };\n\n    _this.handleScrollLeftRequest = function (scrollLeft) {\n      var scrollGrid = _this.scrollGridRef.current;\n      scrollGrid.forceScrollLeft(0, scrollLeft);\n    };\n\n    _this.handleMaxCushionWidth = function (slotCushionMaxWidth) {\n      _this.setState({\n        slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth) // for less rerendering TODO: DRY\n\n      });\n    };\n\n    return _this;\n  }\n\n  TimelineView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var options = context.options;\n    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options);\n    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options);\n    var tDateProfile = this.buildTimelineDateProfile(props.dateProfile, context.dateEnv, options, context.dateProfileGenerator);\n    var extraClassNames = ['fc-timeline', options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : ''];\n    var slotMinWidth = options.slotMinWidth;\n    var slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile));\n    var sections = [{\n      type: 'header',\n      key: 'header',\n      isSticky: stickyHeaderDates,\n      chunks: [{\n        key: 'timeline',\n        content: function content(contentArg) {\n          return createElement(TimelineHeader, {\n            dateProfile: props.dateProfile,\n            clientWidth: contentArg.clientWidth,\n            clientHeight: contentArg.clientHeight,\n            tableMinWidth: contentArg.tableMinWidth,\n            tableColGroupNode: contentArg.tableColGroupNode,\n            tDateProfile: tDateProfile,\n            slatCoords: state.slatCoords,\n            onMaxCushionWidth: slotMinWidth ? null : _this.handleMaxCushionWidth\n          });\n        }\n      }]\n    }, {\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'timeline',\n        content: function content(contentArg) {\n          return createElement(TimelineGrid, __assign({}, props, {\n            clientWidth: contentArg.clientWidth,\n            clientHeight: contentArg.clientHeight,\n            tableMinWidth: contentArg.tableMinWidth,\n            tableColGroupNode: contentArg.tableColGroupNode,\n            tDateProfile: tDateProfile,\n            onSlatCoords: _this.handleSlatCoords,\n            onScrollLeftRequest: _this.handleScrollLeftRequest\n          }));\n        }\n      }]\n    }];\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'timeline',\n          content: renderScrollShim\n        }]\n      });\n    }\n\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: extraClassNames.concat(classNames).join(' ')\n      }, createElement(ScrollGrid, {\n        ref: _this.scrollGridRef,\n        liquid: !props.isHeightAuto && !props.forPrint,\n        collapsibleWidth: false,\n        colGroups: [{\n          cols: slatCols\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  TimelineView.prototype.computeFallbackSlotMinWidth = function (tDateProfile) {\n    return Math.max(30, (this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel);\n  };\n\n  return TimelineView;\n}(DateComponent);\n\nfunction buildSlatCols(tDateProfile, slotMinWidth) {\n  return [{\n    span: tDateProfile.slotCnt,\n    minWidth: slotMinWidth || 1 // needs to be a non-zero number to trigger horizontal scrollbars!??????\n\n  }];\n}\n\nvar main = createPlugin({\n  deps: [premiumCommonPlugin],\n  initialView: 'timelineDay',\n  views: {\n    timeline: {\n      component: TimelineView,\n      usesMinMaxTime: true,\n      eventResizableFromStart: true // how is this consumed for TimelineView tho?\n\n    },\n    timelineDay: {\n      type: 'timeline',\n      duration: {\n        days: 1\n      }\n    },\n    timelineWeek: {\n      type: 'timeline',\n      duration: {\n        weeks: 1\n      }\n    },\n    timelineMonth: {\n      type: 'timeline',\n      duration: {\n        months: 1\n      }\n    },\n    timelineYear: {\n      type: 'timeline',\n      duration: {\n        years: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { TimelineCoords, TimelineHeader, TimelineHeaderRows, TimelineLane, TimelineLaneBg, TimelineLaneSlicer, TimelineSlats, TimelineView, buildSlatCols, buildTimelineDateProfile, coordToCss, coordsToCss };","map":{"version":3,"sources":["src/timeline-date-profile.ts","src/TimelineHeaderThInner.tsx","src/TimelineHeaderTh.tsx","src/TimelineHeaderRows.tsx","src/TimelineCoords.ts","src/TimelineHeader.tsx","src/TimelineSlatCell.tsx","src/TimelineSlatsBody.tsx","src/TimelineSlats.tsx","src/event-placement.ts","src/TimelineLaneBg.tsx","src/TimelineLaneSlicer.ts","src/TimelineEvent.tsx","src/TimelineLaneMoreLink.tsx","src/TimelineLane.tsx","src/TimelineGrid.tsx","src/TimelineView.tsx","src/main.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  config, computeVisibleDayRange, Duration, DateProfile, asCleanDays, addDays, wholeDivideDurations, DateMarker,\n  startOfDay, createDuration, DateEnv, diffWholeDays, asRoughMs, createFormatter, greatestDurationDenominator,\n  asRoughMinutes, padStart, asRoughSeconds, DateRange, isInt, DateProfileGenerator, BaseOptionsRefined,\n} from '@fullcalendar/common'\n\nexport interface TimelineDateProfile {\n  labelInterval: Duration\n  slotDuration: Duration\n  slotsPerLabel: number\n  headerFormats: any\n  isTimeScale: boolean\n  largeUnit: string\n  emphasizeWeeks: boolean\n  snapDuration: Duration\n  snapsPerSlot: number\n  normalizedRange: DateRange // snaps to unit. adds in slotMinTime/slotMaxTime\n  timeWindowMs: number\n  slotDates: DateMarker[]\n  isWeekStarts: boolean[]\n  snapDiffToIndex: number[]\n  snapIndexToDiff: number[]\n  snapCnt: number\n  slotCnt: number\n  cellRows: TimelineHeaderCell[][]\n}\n\nexport interface TimelineHeaderCell {\n  date: DateMarker\n  text: string\n  rowUnit: string\n  colspan: number\n  isWeekStart: boolean\n}\n\nconst MIN_AUTO_LABELS = 18 // more than `12` months but less that `24` hours\nconst MAX_AUTO_SLOTS_PER_LABEL = 6 // allows 6 10-min slots in an hour\nconst MAX_AUTO_CELLS = 200 // allows 4-days to have a :30 slot duration\nconfig.MAX_TIMELINE_SLOTS = 1000\n\n// potential nice values for slot-duration and interval-duration\nconst STOCK_SUB_DURATIONS = [ // from largest to smallest\n  { years: 1 },\n  { months: 1 },\n  { days: 1 },\n  { hours: 1 },\n  { minutes: 30 },\n  { minutes: 15 },\n  { minutes: 10 },\n  { minutes: 5 },\n  { minutes: 1 },\n  { seconds: 30 },\n  { seconds: 15 },\n  { seconds: 10 },\n  { seconds: 5 },\n  { seconds: 1 },\n  { milliseconds: 500 },\n  { milliseconds: 100 },\n  { milliseconds: 10 },\n  { milliseconds: 1 },\n]\n\nexport function buildTimelineDateProfile(\n  dateProfile: DateProfile,\n  dateEnv: DateEnv,\n  allOptions: BaseOptionsRefined,\n  dateProfileGenerator: DateProfileGenerator,\n): TimelineDateProfile {\n  let tDateProfile = {\n    labelInterval: allOptions.slotLabelInterval,\n    slotDuration: allOptions.slotDuration,\n  } as TimelineDateProfile\n\n  validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) // validate after computed grid duration\n  ensureLabelInterval(tDateProfile, dateProfile, dateEnv)\n  ensureSlotDuration(tDateProfile, dateProfile, dateEnv)\n\n  let input = allOptions.slotLabelFormat\n  let rawFormats =\n    Array.isArray(input) ? input :\n      (input != null) ? [input] :\n        computeHeaderFormats(tDateProfile, dateProfile, dateEnv, allOptions)\n\n  tDateProfile.headerFormats = rawFormats.map((rawFormat) => createFormatter(rawFormat))\n\n  tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds)\n\n  let largeUnit = null\n  if (!tDateProfile.isTimeScale) {\n    const slotUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit\n    if (/year|month|week/.test(slotUnit)) {\n      largeUnit = slotUnit\n    }\n  }\n\n  tDateProfile.largeUnit = largeUnit\n\n  tDateProfile.emphasizeWeeks =\n    asCleanDays(tDateProfile.slotDuration) === 1 &&\n    currentRangeAs('weeks', dateProfile, dateEnv) >= 2 &&\n    !allOptions.businessHours\n\n  /*\n  console.log('label interval =', timelineView.labelInterval.humanize())\n  console.log('slot duration =', timelineView.slotDuration.humanize())\n  console.log('header formats =', timelineView.headerFormats)\n  console.log('isTimeScale', timelineView.isTimeScale)\n  console.log('largeUnit', timelineView.largeUnit)\n  */\n\n  let rawSnapDuration = allOptions.snapDuration\n  let snapDuration\n  let snapsPerSlot\n\n  if (rawSnapDuration) {\n    snapDuration = createDuration(rawSnapDuration)\n    snapsPerSlot = wholeDivideDurations(tDateProfile.slotDuration, snapDuration)\n    // ^ TODO: warning if not whole?\n  }\n\n  if (snapsPerSlot == null) {\n    snapDuration = tDateProfile.slotDuration\n    snapsPerSlot = 1\n  }\n\n  tDateProfile.snapDuration = snapDuration\n  tDateProfile.snapsPerSlot = snapsPerSlot\n\n  // more...\n\n  let timeWindowMs = asRoughMs(dateProfile.slotMaxTime) - asRoughMs(dateProfile.slotMinTime)\n\n  // TODO: why not use normalizeRange!?\n  let normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv)\n  let normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv)\n\n  // apply slotMinTime/slotMaxTime\n  // TODO: View should be responsible.\n  if (tDateProfile.isTimeScale) {\n    normalizedStart = dateEnv.add(normalizedStart, dateProfile.slotMinTime)\n    normalizedEnd = dateEnv.add(\n      addDays(normalizedEnd, -1),\n      dateProfile.slotMaxTime,\n    )\n  }\n\n  tDateProfile.timeWindowMs = timeWindowMs\n  tDateProfile.normalizedRange = { start: normalizedStart, end: normalizedEnd }\n\n  let slotDates = []\n  let date = normalizedStart\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      slotDates.push(date)\n    }\n    date = dateEnv.add(date, tDateProfile.slotDuration)\n  }\n\n  tDateProfile.slotDates = slotDates\n\n  // more...\n\n  let snapIndex = -1\n  let snapDiff = 0 // index of the diff :(\n  const snapDiffToIndex = []\n  const snapIndexToDiff = []\n\n  date = normalizedStart\n  while (date < normalizedEnd) {\n    if (isValidDate(date, tDateProfile, dateProfile, dateProfileGenerator)) {\n      snapIndex += 1\n      snapDiffToIndex.push(snapIndex)\n      snapIndexToDiff.push(snapDiff)\n    } else {\n      snapDiffToIndex.push(snapIndex + 0.5)\n    }\n    date = dateEnv.add(date, tDateProfile.snapDuration)\n    snapDiff += 1\n  }\n\n  tDateProfile.snapDiffToIndex = snapDiffToIndex\n  tDateProfile.snapIndexToDiff = snapIndexToDiff\n\n  tDateProfile.snapCnt = snapIndex + 1 // is always one behind\n  tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot\n\n  // more...\n\n  tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv)\n  tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv)\n  tDateProfile.slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration)\n\n  return tDateProfile\n}\n\n/*\nsnaps to appropriate unit\n*/\nexport function normalizeDate(date: DateMarker, tDateProfile: TimelineDateProfile, dateEnv: DateEnv): DateMarker {\n  let normalDate = date\n\n  if (!tDateProfile.isTimeScale) {\n    normalDate = startOfDay(normalDate)\n\n    if (tDateProfile.largeUnit) {\n      normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit)\n    }\n  }\n\n  return normalDate\n}\n\n/*\nsnaps to appropriate unit\n*/\nexport function normalizeRange(range: DateRange, tDateProfile: TimelineDateProfile, dateEnv: DateEnv): DateRange {\n  if (!tDateProfile.isTimeScale) {\n    range = computeVisibleDayRange(range)\n\n    if (tDateProfile.largeUnit) {\n      let dayRange = range // preserve original result\n\n      range = {\n        start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n        end: dateEnv.startOf(range.end, tDateProfile.largeUnit),\n      }\n\n      // if date is partially through the interval, or is in the same interval as the start,\n      // make the exclusive end be the *next* interval\n      if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n        range = {\n          start: range.start,\n          end: dateEnv.add(range.end, tDateProfile.slotDuration),\n        }\n      }\n    }\n  }\n\n  return range\n}\n\nexport function isValidDate(\n  date: DateMarker,\n  tDateProfile: TimelineDateProfile,\n  dateProfile: DateProfile,\n  dateProfileGenerator: DateProfileGenerator,\n) {\n  if (dateProfileGenerator.isHiddenDay(date)) {\n    return false\n  }\n\n  if (tDateProfile.isTimeScale) {\n    // determine if the time is within slotMinTime/slotMaxTime, which may have wacky values\n    let day = startOfDay(date)\n    let timeMs = date.valueOf() - day.valueOf()\n    let ms = timeMs - asRoughMs(dateProfile.slotMinTime) // milliseconds since slotMinTime\n    ms = ((ms % 86400000) + 86400000) % 86400000 // make negative values wrap to 24hr clock\n    return ms < tDateProfile.timeWindowMs // before the slotMaxTime?\n  }\n\n  return true\n}\n\nfunction validateLabelAndSlot(tDateProfile: TimelineDateProfile, dateProfile: DateProfile, dateEnv: DateEnv) {\n  const { currentRange } = dateProfile\n\n  // make sure labelInterval doesn't exceed the max number of cells\n  if (tDateProfile.labelInterval) {\n    const labelCnt = dateEnv.countDurationsBetween(\n      currentRange.start,\n      currentRange.end,\n      tDateProfile.labelInterval,\n    )\n    if (labelCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotLabelInterval results in too many cells')\n      tDateProfile.labelInterval = null\n    }\n  }\n\n  // make sure slotDuration doesn't exceed the maximum number of cells\n  if (tDateProfile.slotDuration) {\n    const slotCnt = dateEnv.countDurationsBetween(\n      currentRange.start,\n      currentRange.end,\n      tDateProfile.slotDuration,\n    )\n    if (slotCnt > config.MAX_TIMELINE_SLOTS) {\n      console.warn('slotDuration results in too many cells')\n      tDateProfile.slotDuration = null\n    }\n  }\n\n  // make sure labelInterval is a multiple of slotDuration\n  if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n    const slotsPerLabel = wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration)\n    if (slotsPerLabel === null || slotsPerLabel < 1) {\n      console.warn('slotLabelInterval must be a multiple of slotDuration')\n      tDateProfile.slotDuration = null\n    }\n  }\n}\n\nfunction ensureLabelInterval(tDateProfile: TimelineDateProfile, dateProfile: DateProfile, dateEnv: DateEnv) {\n  const { currentRange } = dateProfile\n  let { labelInterval } = tDateProfile\n\n  if (!labelInterval) {\n    // compute based off the slot duration\n    // find the largest label interval with an acceptable slots-per-label\n    let input\n    if (tDateProfile.slotDuration) {\n      for (input of STOCK_SUB_DURATIONS) {\n        const tryLabelInterval = createDuration(input)\n        const slotsPerLabel = wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration)\n        if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          labelInterval = tryLabelInterval\n          break\n        }\n      }\n\n      // use the slot duration as a last resort\n      if (!labelInterval) {\n        labelInterval = tDateProfile.slotDuration\n      }\n\n    // compute based off the view's duration\n    // find the largest label interval that yields the minimum number of labels\n    } else {\n      for (input of STOCK_SUB_DURATIONS) {\n        labelInterval = createDuration(input)\n        const labelCnt = dateEnv.countDurationsBetween(\n          currentRange.start,\n          currentRange.end,\n          labelInterval,\n        )\n        if (labelCnt >= MIN_AUTO_LABELS) {\n          break\n        }\n      }\n    }\n\n    tDateProfile.labelInterval = labelInterval\n  }\n\n  return labelInterval\n}\n\nfunction ensureSlotDuration(tDateProfile: TimelineDateProfile, dateProfile: DateProfile, dateEnv: DateEnv) {\n  const { currentRange } = dateProfile\n  let { slotDuration } = tDateProfile\n\n  if (!slotDuration) {\n    const labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv) // will compute if necessary\n\n    // compute based off the label interval\n    // find the largest slot duration that is different from labelInterval, but still acceptable\n    for (let input of STOCK_SUB_DURATIONS) {\n      const trySlotDuration = createDuration(input)\n      const slotsPerLabel = wholeDivideDurations(labelInterval, trySlotDuration)\n      if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n        slotDuration = trySlotDuration\n        break\n      }\n    }\n\n    // only allow the value if it won't exceed the view's # of slots limit\n    if (slotDuration) {\n      const slotCnt = dateEnv.countDurationsBetween(\n        currentRange.start,\n        currentRange.end,\n        slotDuration,\n      )\n      if (slotCnt > MAX_AUTO_CELLS) {\n        slotDuration = null\n      }\n    }\n\n    // use the label interval as a last resort\n    if (!slotDuration) {\n      slotDuration = labelInterval\n    }\n\n    tDateProfile.slotDuration = slotDuration\n  }\n\n  return slotDuration\n}\n\nfunction computeHeaderFormats(\n  tDateProfile: TimelineDateProfile,\n  dateProfile: DateProfile,\n  dateEnv: DateEnv,\n  allOptions: BaseOptionsRefined,\n) {\n  let format1\n  let format2\n  const { labelInterval } = tDateProfile\n  let unit = greatestDurationDenominator(labelInterval).unit\n  const weekNumbersVisible = allOptions.weekNumbers\n  let format0 = (format1 = (format2 = null))\n\n  // NOTE: weekNumber computation function wont work\n\n  if ((unit === 'week') && !weekNumbersVisible) {\n    unit = 'day'\n  }\n\n  switch (unit) {\n    case 'year':\n      format0 = { year: 'numeric' } // '2015'\n      break\n\n    case 'month':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = { year: 'numeric' } // '2015'\n      }\n\n      format1 = { month: 'short' } // 'Jan'\n      break\n\n    case 'week':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = { year: 'numeric' } // '2015'\n      }\n\n      format1 = { week: 'narrow' } // 'Wk4'\n      break\n\n    case 'day':\n      if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n        format0 = { year: 'numeric', month: 'long' } // 'January 2014'\n      } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n        format0 = { month: 'long' } // 'January'\n      }\n\n      if (weekNumbersVisible) {\n        format1 = { week: 'short' } // 'Wk 4'\n      }\n\n      format2 = { weekday: 'narrow', day: 'numeric' } // 'Su 9'\n      break\n\n    case 'hour':\n      if (weekNumbersVisible) {\n        format0 = { week: 'short' } // 'Wk 4'\n      }\n\n      if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n        format1 = { weekday: 'short', day: 'numeric', month: 'numeric', omitCommas: true } // Sat 4/7\n      }\n\n      format2 = {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short',\n      }\n      break\n\n    case 'minute':\n      // sufficiently large number of different minute cells?\n      if ((asRoughMinutes(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = {\n          hour: 'numeric',\n          meridiem: 'short',\n        }\n        format1 = (params) => (\n          ':' + padStart(params.date.minute, 2) // ':30'\n        )\n      } else {\n        format0 = {\n          hour: 'numeric',\n          minute: 'numeric',\n          meridiem: 'short',\n        }\n      }\n      break\n\n    case 'second':\n      // sufficiently large number of different second cells?\n      if ((asRoughSeconds(labelInterval) / 60) >= MAX_AUTO_SLOTS_PER_LABEL) {\n        format0 = { hour: 'numeric', minute: '2-digit', meridiem: 'lowercase' } // '8:30 PM'\n        format1 = (params) => (\n          ':' + padStart(params.date.second, 2) // ':30'\n        )\n      } else {\n        format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' } // '8:30:45 PM'\n      }\n      break\n\n    case 'millisecond':\n      format0 = { hour: 'numeric', minute: '2-digit', second: '2-digit', meridiem: 'lowercase' } // '8:30:45 PM'\n      format1 = (params) => (\n        '.' + padStart(params.millisecond, 3)\n      )\n      break\n  }\n\n  return [].concat(format0 || [], format1 || [], format2 || [])\n}\n\n// Compute the number of the give units in the \"current\" range.\n// Won't go more precise than days.\n// Will return `0` if there's not a clean whole interval.\nfunction currentRangeAs(unit: string, dateProfile: DateProfile, dateEnv: DateEnv) {\n  let range = dateProfile.currentRange\n  let res = null\n\n  if (unit === 'years') {\n    res = dateEnv.diffWholeYears(range.start, range.end)\n  } else if (unit === 'months') {\n    res = dateEnv.diffWholeMonths(range.start, range.end)\n  } else if (unit === 'weeks') {\n    res = dateEnv.diffWholeMonths(range.start, range.end)\n  } else if (unit === 'days') {\n    res = diffWholeDays(range.start, range.end)\n  }\n\n  return res || 0\n}\n\nfunction buildIsWeekStarts(tDateProfile: TimelineDateProfile, dateEnv: DateEnv) {\n  let { slotDates, emphasizeWeeks } = tDateProfile\n  let prevWeekNumber = null\n  let isWeekStarts: boolean[] = []\n\n  for (let slotDate of slotDates) {\n    let weekNumber = dateEnv.computeWeekNumber(slotDate)\n    let isWeekStart = emphasizeWeeks && (prevWeekNumber !== null) && (prevWeekNumber !== weekNumber)\n    prevWeekNumber = weekNumber\n\n    isWeekStarts.push(isWeekStart)\n  }\n\n  return isWeekStarts\n}\n\nfunction buildCellRows(tDateProfile: TimelineDateProfile, dateEnv: DateEnv) {\n  let slotDates = tDateProfile.slotDates\n  let formats = tDateProfile.headerFormats\n  let cellRows = formats.map(() => []) // indexed by row,col\n  let slotAsDays = asCleanDays(tDateProfile.slotDuration)\n  let guessedSlotUnit =\n    slotAsDays === 7 ? 'week' :\n      slotAsDays === 1 ? 'day' :\n        null\n\n  // specifically for navclicks\n  let rowUnitsFromFormats = formats.map(\n    (format) => (format.getLargestUnit ? format.getLargestUnit() : null),\n  )\n\n  // builds cellRows and slotCells\n  for (let i = 0; i < slotDates.length; i += 1) {\n    let date = slotDates[i]\n    let isWeekStart = tDateProfile.isWeekStarts[i]\n\n    for (let row = 0; row < formats.length; row += 1) {\n      let format = formats[row]\n      let rowCells = cellRows[row]\n      let leadingCell = rowCells[rowCells.length - 1]\n      let isLastRow = row === formats.length - 1\n      let isSuperRow = formats.length > 1 && !isLastRow // more than one row and not the last\n      let newCell = null\n      let rowUnit = rowUnitsFromFormats[row] || (isLastRow ? guessedSlotUnit : null)\n\n      if (isSuperRow) {\n        let text = dateEnv.format(date, format)\n        if (!leadingCell || (leadingCell.text !== text)) {\n          newCell = buildCellObject(date, text, rowUnit)\n        } else {\n          leadingCell.colspan += 1\n        }\n      } else if (\n        !leadingCell ||\n        isInt(dateEnv.countDurationsBetween(\n          tDateProfile.normalizedRange.start,\n          date,\n          tDateProfile.labelInterval,\n        ))\n      ) {\n        let text = dateEnv.format(date, format)\n        newCell = buildCellObject(date, text, rowUnit)\n      } else {\n        leadingCell.colspan += 1\n      }\n\n      if (newCell) {\n        newCell.weekStart = isWeekStart\n        rowCells.push(newCell)\n      }\n    }\n  }\n\n  return cellRows\n}\n\nfunction buildCellObject(date: DateMarker, text, rowUnit): TimelineHeaderCell {\n  return { date, text, rowUnit, colspan: 1, isWeekStart: false }\n}\n","import { createElement, BaseComponent, DateMarker, ContentHook, ViewApi, DateEnv } from '@fullcalendar/common'\n\nexport interface TimelineHeaderThInnerProps {\n  hookProps: HookProps\n  isSticky: boolean\n  navLinkAttrs: object | null\n}\n\nexport class TimelineHeaderThInner extends BaseComponent<TimelineHeaderThInnerProps> {\n  render() {\n    let { props, context } = this\n\n    return (\n      <ContentHook hookProps={props.hookProps} content={context.options.slotLabelContent} defaultContent={renderInnerContent}>\n        {(innerElRef, innerContent) => (\n          <a\n            ref={innerElRef}\n            className={'fc-timeline-slot-cushion fc-scrollgrid-sync-inner' + (props.isSticky ? ' fc-sticky' : '')}\n            {...props.navLinkAttrs}\n          >\n            {innerContent}\n          </a>\n        )}\n      </ContentHook>\n    )\n  }\n}\n\nfunction renderInnerContent(props) { // TODO: add types\n  return props.text\n}\n\n// hook props\n// ----------\n\nexport interface HookPropsInput {\n  level: number\n  dateMarker: DateMarker\n  text: string\n  dateEnv: DateEnv\n  viewApi: ViewApi\n}\n\nexport interface HookProps {\n  level: number\n  date: DateMarker // localized\n  view: ViewApi\n  text: string\n}\n\nexport function refineHookProps(input: HookPropsInput): HookProps {\n  return {\n    level: input.level,\n    date: input.dateEnv.toDate(input.dateMarker),\n    view: input.viewApi,\n    text: input.text,\n  }\n}\n","import {\n  createElement, BaseComponent, DateRange, DateMarker, getDateMeta, getSlotClassNames,\n  buildNavLinkAttrs, buildClassNameNormalizer, MountHook,\n  getDayClassNames, DateProfile, memoizeObjArg, ViewContext, memoize,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile, TimelineHeaderCell } from './timeline-date-profile'\nimport { TimelineHeaderThInner, refineHookProps, HookProps } from './TimelineHeaderThInner'\n\nexport interface TimelineHeaderThProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  rowLevel: number\n  cell: TimelineHeaderCell\n  todayRange: DateRange\n  nowDate: DateMarker\n  rowInnerHeight?: number\n  isSticky: boolean\n}\n\nexport class TimelineHeaderTh extends BaseComponent<TimelineHeaderThProps> {\n  refineHookProps = memoizeObjArg(refineHookProps)\n  normalizeClassNames = buildClassNameNormalizer<HookProps>()\n  buildCellNavLinkAttrs = memoize(buildCellNavLinkAttrs)\n\n  render() {\n    let { props, context } = this\n    let { dateEnv, options } = context\n    let { cell, dateProfile, tDateProfile } = props\n\n    // the cell.rowUnit is f'd\n    // giving 'month' for a 3-day view\n    // workaround: to infer day, do NOT time\n\n    let dateMeta = getDateMeta(cell.date, props.todayRange, props.nowDate, dateProfile)\n\n    let classNames = ['fc-timeline-slot', 'fc-timeline-slot-label'].concat(\n      cell.rowUnit === 'time' // TODO: so slot classnames for week/month/bigger. see note above about rowUnit\n        ? getSlotClassNames(dateMeta, context.theme)\n        : getDayClassNames(dateMeta, context.theme),\n    )\n\n    if (cell.isWeekStart) {\n      classNames.push('fc-timeline-slot-em')\n    }\n\n    let hookProps = this.refineHookProps({\n      level: props.rowLevel,\n      dateMarker: cell.date,\n      text: cell.text,\n      dateEnv: context.dateEnv,\n      viewApi: context.viewApi,\n    })\n\n    let customClassNames = this.normalizeClassNames(options.slotLabelClassNames, hookProps)\n\n    return (\n      <MountHook hookProps={hookProps} didMount={options.slotLabelDidMount} willUnmount={options.slotLabelWillUnmount}>\n        {(rootElRef) => (\n          <th\n            ref={rootElRef}\n            className={classNames.concat(customClassNames).join(' ')}\n            data-date={dateEnv.formatIso(cell.date, { omitTime: !tDateProfile.isTimeScale, omitTimeZoneOffset: true })}\n            colSpan={cell.colspan}\n          >\n            <div className=\"fc-timeline-slot-frame\" style={{ height: props.rowInnerHeight }}>\n              <TimelineHeaderThInner\n                hookProps={hookProps}\n                isSticky={props.isSticky}\n                navLinkAttrs={this.buildCellNavLinkAttrs(context, cell.date, cell.rowUnit)}\n              />\n            </div>\n          </th>\n        )}\n      </MountHook>\n    )\n  }\n}\n\nfunction buildCellNavLinkAttrs(context: ViewContext, cellDate: DateMarker, rowUnit: string): object {\n  return (rowUnit && rowUnit !== 'time')\n    ? buildNavLinkAttrs(context, cellDate, rowUnit)\n    : {}\n}\n","import { createElement, BaseComponent, Fragment, DateRange, DateMarker, DateProfile } from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\nimport { TimelineHeaderTh } from './TimelineHeaderTh'\n\nexport interface TimelineHeaderRowsProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  rowInnerHeights?: number[]\n}\n\nexport class TimelineHeaderRows extends BaseComponent<TimelineHeaderRowsProps> {\n  render() {\n    let { dateProfile, tDateProfile, rowInnerHeights, todayRange, nowDate } = this.props\n    let { cellRows } = tDateProfile\n\n    return (\n      <Fragment>\n        {cellRows.map((rowCells, rowLevel) => {\n          let isLast = rowLevel === cellRows.length - 1\n          let isChrono = tDateProfile.isTimeScale && isLast // the final row, with times?\n          let classNames = [\n            'fc-timeline-header-row',\n            isChrono ? 'fc-timeline-header-row-chrono' : '',\n          ]\n\n          return ( // eslint-disable-next-line react/no-array-index-key\n            <tr key={rowLevel} className={classNames.join(' ')}>\n              {rowCells.map((cell) => (\n                <TimelineHeaderTh\n                  key={cell.date.toISOString()}\n                  cell={cell}\n                  rowLevel={rowLevel}\n                  dateProfile={dateProfile}\n                  tDateProfile={tDateProfile}\n                  todayRange={todayRange}\n                  nowDate={nowDate}\n                  rowInnerHeight={rowInnerHeights && rowInnerHeights[rowLevel]}\n                  isSticky={!isLast}\n                />\n              ))}\n            </tr>\n          )\n        })}\n      </Fragment>\n    )\n  }\n}\n","import {\n  PositionCache, findDirectChildren,\n  isInt, DateProfile,\n  DateMarker, DateEnv, Duration, startOfDay, rangeContainsMarker, CssDimValue, DateRange, SegSpan,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport class TimelineCoords { // TODO: rename to \"slat\" coords?\n  outerCoordCache: PositionCache\n  innerCoordCache: PositionCache\n\n  constructor(\n    public slatRootEl: HTMLElement, // okay to expose?\n    slatEls: HTMLElement[],\n    public dateProfile: DateProfile,\n    private tDateProfile: TimelineDateProfile,\n    private dateEnv: DateEnv,\n    public isRtl: boolean,\n  ) {\n    this.outerCoordCache = new PositionCache(\n      slatRootEl,\n      slatEls,\n      true, // isHorizontal\n      false, // isVertical\n    )\n\n    // for the inner divs within the slats\n    // used for event rendering and scrollTime, to disregard slat border\n    this.innerCoordCache = new PositionCache(\n      slatRootEl,\n      findDirectChildren(slatEls, 'div'),\n      true, // isHorizontal\n      false, // isVertical\n    )\n  }\n\n  isDateInRange(date: DateMarker) {\n    return rangeContainsMarker(this.dateProfile.currentRange, date)\n  }\n\n  // results range from negative width of area to 0\n  dateToCoord(date: DateMarker): number {\n    let { tDateProfile } = this\n    let snapCoverage = this.computeDateSnapCoverage(date)\n    let slotCoverage = snapCoverage / tDateProfile.snapsPerSlot\n    let slotIndex = Math.floor(slotCoverage)\n    slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1)\n    let partial = slotCoverage - slotIndex\n    let { innerCoordCache, outerCoordCache } = this\n\n    if (this.isRtl) {\n      return outerCoordCache.originClientRect.width - (\n        outerCoordCache.rights[slotIndex] -\n        (innerCoordCache.getWidth(slotIndex) * partial)\n      )\n    }\n\n    return (\n      outerCoordCache.lefts[slotIndex] +\n      (innerCoordCache.getWidth(slotIndex) * partial)\n    )\n  }\n\n  rangeToCoords(range: DateRange): SegSpan {\n    return {\n      start: this.dateToCoord(range.start),\n      end: this.dateToCoord(range.end),\n    }\n  }\n\n  durationToCoord(duration: Duration): number {\n    let { dateProfile, tDateProfile, dateEnv, isRtl } = this\n    let coord = 0\n\n    if (dateProfile) {\n      let date = dateEnv.add(dateProfile.activeRange.start, duration)\n\n      if (!tDateProfile.isTimeScale) {\n        date = startOfDay(date)\n      }\n\n      coord = this.dateToCoord(date)\n\n      // hack to overcome the left borders of non-first slat\n      if (!isRtl && coord) {\n        coord += 1\n      }\n    }\n\n    return coord\n  }\n\n  coordFromLeft(coord: number) {\n    if (this.isRtl) {\n      return this.outerCoordCache.originClientRect.width - coord\n    }\n    return coord\n  }\n\n  // returned value is between 0 and the number of snaps\n  computeDateSnapCoverage(date: DateMarker): number {\n    return computeDateSnapCoverage(date, this.tDateProfile, this.dateEnv)\n  }\n}\n\n// returned value is between 0 and the number of snaps\nexport function computeDateSnapCoverage(date: DateMarker, tDateProfile: TimelineDateProfile, dateEnv: DateEnv): number {\n  let snapDiff = dateEnv.countDurationsBetween(\n    tDateProfile.normalizedRange.start,\n    date,\n    tDateProfile.snapDuration,\n  )\n\n  if (snapDiff < 0) {\n    return 0\n  }\n\n  if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n    return tDateProfile.snapCnt\n  }\n\n  let snapDiffInt = Math.floor(snapDiff)\n  let snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt]\n\n  if (isInt(snapCoverage)) { // not an in-between value\n    snapCoverage += snapDiff - snapDiffInt // add the remainder\n  } else {\n    // a fractional value, meaning the date is not visible\n    // always round up in this case. works for start AND end dates in a range.\n    snapCoverage = Math.ceil(snapCoverage)\n  }\n\n  return snapCoverage\n}\n\nexport function coordToCss(\n  hcoord: number | null,\n  isRtl: boolean,\n): { left: CssDimValue, right: CssDimValue } {\n  if (hcoord === null) {\n    return { left: '', right: '' }\n  }\n  if (isRtl) {\n    return { right: hcoord, left: '' }\n  }\n  return { left: hcoord, right: '' }\n}\n\nexport function coordsToCss(\n  hcoords: SegSpan | null,\n  isRtl: boolean,\n): { left: CssDimValue, right: CssDimValue } {\n  if (!hcoords) {\n    return { left: '', right: '' }\n  }\n  if (isRtl) {\n    return { right: hcoords.start, left: -hcoords.end }\n  }\n  return { left: hcoords.start, right: -hcoords.end }\n}\n","import {\n  createElement, BaseComponent, CssDimValue, VNode, DateMarker, NowTimer,\n  greatestDurationDenominator, DateRange, NowIndicatorRoot, createRef,\n  findElements, RefObject, DateProfile,\n} from '@fullcalendar/common'\nimport { TimelineHeaderRows } from './TimelineHeaderRows'\nimport { coordToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport interface TimelineHeaderProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  clientWidth: number | null\n  clientHeight: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  slatCoords: TimelineCoords\n  rowInnerHeights?: number[]\n  onMaxCushionWidth?: (number) => void\n}\n\nexport class TimelineHeader extends BaseComponent<TimelineHeaderProps> {\n  rootElRef: RefObject<HTMLDivElement> = createRef<HTMLDivElement>()\n\n  render() {\n    let { props, context } = this\n\n    // TODO: very repetitive\n    // TODO: make part of tDateProfile?\n    let timerUnit = greatestDurationDenominator(props.tDateProfile.slotDuration).unit\n\n    // WORKAROUND: make ignore slatCoords when out of sync with dateProfile\n    let slatCoords = props.slatCoords && props.slatCoords.dateProfile === props.dateProfile ? props.slatCoords : null\n\n    return (\n      <NowTimer unit={timerUnit}>\n        {(nowDate: DateMarker, todayRange: DateRange) => (\n          <div className=\"fc-timeline-header\" ref={this.rootElRef}>\n            <table\n              aria-hidden\n              className=\"fc-scrollgrid-sync-table\"\n              style={{ minWidth: props.tableMinWidth, width: props.clientWidth }}\n            >\n              {props.tableColGroupNode}\n              <tbody>\n                <TimelineHeaderRows\n                  dateProfile={props.dateProfile}\n                  tDateProfile={props.tDateProfile}\n                  nowDate={nowDate}\n                  todayRange={todayRange}\n                  rowInnerHeights={props.rowInnerHeights}\n                />\n              </tbody>\n            </table>\n            {context.options.nowIndicator && (\n              // need to have a container regardless of whether the current view has a visible now indicator\n              // because apparently removal of the element resets the scroll for some reasons (issue #5351).\n              // this issue doesn't happen for the timeline body however (\n              <div className=\"fc-timeline-now-indicator-container\">\n                {(slatCoords && slatCoords.isDateInRange(nowDate)) && (\n                  <NowIndicatorRoot isAxis date={nowDate}>\n                    {(rootElRef, classNames, innerElRef, innerContent) => (\n                      <div\n                        ref={rootElRef}\n                        className={['fc-timeline-now-indicator-arrow'].concat(classNames).join(' ')}\n                        style={coordToCss(slatCoords.dateToCoord(nowDate), context.isRtl)}\n                      >\n                        {innerContent}\n                      </div>\n                    )}\n                  </NowIndicatorRoot>\n                )}\n              </div>\n            )}\n          </div>\n        )}\n      </NowTimer>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSize()\n  }\n\n  componentDidUpdate() {\n    this.updateSize()\n  }\n\n  updateSize() {\n    if (this.props.onMaxCushionWidth) {\n      this.props.onMaxCushionWidth(this.computeMaxCushionWidth())\n    }\n  }\n\n  computeMaxCushionWidth() { // TODO: called way too often\n    return Math.max(\n      ...findElements(this.rootElRef.current, '.fc-timeline-header-row:last-child .fc-timeline-slot-cushion').map(\n        (el) => el.getBoundingClientRect().width,\n      ),\n    )\n  }\n}\n","import {\n  createElement, isInt, BaseComponent, DateMarker, Ref, DateRange, getDateMeta, getSlotClassNames,\n  RenderHook, getDayClassNames, SlotLaneContentArg, DateProfile,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport interface TimelineSlatCellProps {\n  date: DateMarker\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  isDay: boolean\n  isEm: boolean\n  elRef?: Ref<HTMLTableCellElement>\n}\n\nexport class TimelineSlatCell extends BaseComponent<TimelineSlatCellProps> {\n  render() {\n    let { props, context } = this\n    let { dateEnv, options, theme } = context\n    let { date, tDateProfile, isEm } = props\n    let dateMeta = getDateMeta(props.date, props.todayRange, props.nowDate, props.dateProfile)\n    let classNames = ['fc-timeline-slot', 'fc-timeline-slot-lane']\n    let dataAttrs = { 'data-date': dateEnv.formatIso(date, { omitTimeZoneOffset: true, omitTime: !tDateProfile.isTimeScale }) }\n    let hookProps: SlotLaneContentArg = {\n      date: dateEnv.toDate(props.date),\n      ...dateMeta,\n      view: context.viewApi,\n    }\n\n    if (isEm) {\n      classNames.push('fc-timeline-slot-em')\n    }\n\n    if (tDateProfile.isTimeScale) {\n      classNames.push(\n        isInt(dateEnv.countDurationsBetween(\n          tDateProfile.normalizedRange.start,\n          props.date,\n          tDateProfile.labelInterval,\n        )) ?\n          'fc-timeline-slot-major' :\n          'fc-timeline-slot-minor',\n      )\n    }\n\n    classNames.push(...(\n      props.isDay\n        ? getDayClassNames(dateMeta, theme)\n        : getSlotClassNames(dateMeta, theme)\n    ))\n\n    return (\n      <RenderHook\n        hookProps={hookProps}\n        classNames={options.slotLaneClassNames}\n        content={options.slotLaneContent}\n        didMount={options.slotLaneDidMount}\n        willUnmount={options.slotLaneWillUnmount}\n        elRef={props.elRef}\n      >\n        {(rootElRef, customClassNames, innerElRef, innerContent) => (\n          <td\n            ref={rootElRef}\n            className={classNames.concat(customClassNames).join(' ')}\n            {...dataAttrs}\n          >\n            <div ref={innerElRef}>{innerContent}</div>\n          </td>\n        )}\n      </RenderHook>\n    )\n  }\n}\n","import { createElement, BaseComponent, RefMap, DateMarker, DateRange, DateProfile } from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\nimport { TimelineSlatCell } from './TimelineSlatCell'\n\nexport interface TimelineSlatsContentProps {\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n}\n\nexport interface TimelineSlatsBodyProps extends TimelineSlatsContentProps {\n  cellElRefs: RefMap<HTMLTableCellElement>\n}\n\nexport class TimelineSlatsBody extends BaseComponent<TimelineSlatsBodyProps> {\n  render() {\n    let { props } = this\n    let { tDateProfile, cellElRefs } = props\n    let { slotDates, isWeekStarts } = tDateProfile\n    let isDay = !tDateProfile.isTimeScale && !tDateProfile.largeUnit\n\n    return (\n      <tbody>\n        <tr>\n          {slotDates.map((slotDate, i) => {\n            let key = slotDate.toISOString()\n\n            return (\n              <TimelineSlatCell\n                key={key}\n                elRef={cellElRefs.createRef(key)}\n                date={slotDate}\n                dateProfile={props.dateProfile}\n                tDateProfile={tDateProfile}\n                nowDate={props.nowDate}\n                todayRange={props.todayRange}\n                isEm={isWeekStarts[i]}\n                isDay={isDay}\n              />\n            )\n          })}\n        </tr>\n      </tbody>\n    )\n  }\n}\n","import {\n  createElement, BaseComponent, multiplyDuration, RefMap, CssDimValue, VNode,\n  createRef, ScrollResponder, ScrollRequest, DateMarker,\n} from '@fullcalendar/common'\nimport { TimelineCoords } from './TimelineCoords'\nimport { TimelineSlatsBody, TimelineSlatsContentProps } from './TimelineSlatsBody'\n\nexport interface TimelineSlatsProps extends TimelineSlatsContentProps {\n  clientWidth: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onCoords?: (coord: TimelineCoords | null) => void\n  onScrollLeftRequest?: (scrollLeft: number) => void\n}\n\nexport class TimelineSlats extends BaseComponent<TimelineSlatsProps> {\n  private rootElRef = createRef<HTMLDivElement>()\n  private cellElRefs = new RefMap<HTMLTableCellElement>()\n  private coords: TimelineCoords // for positionToHit\n  private scrollResponder: ScrollResponder\n\n  render() {\n    let { props, context } = this\n\n    return (\n      <div className=\"fc-timeline-slots\" ref={this.rootElRef}>\n        <table\n          aria-hidden\n          className={context.theme.getClass('table')}\n          style={{\n            minWidth: props.tableMinWidth,\n            width: props.clientWidth,\n          }}\n        >\n          {props.tableColGroupNode}\n          <TimelineSlatsBody\n            cellElRefs={this.cellElRefs}\n            dateProfile={props.dateProfile}\n            tDateProfile={props.tDateProfile}\n            nowDate={props.nowDate}\n            todayRange={props.todayRange}\n          />\n        </table>\n      </div>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSizing()\n    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest)\n  }\n\n  componentDidUpdate(prevProps: TimelineSlatsProps) {\n    this.updateSizing()\n\n    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile)\n  }\n\n  componentWillUnmount() {\n    this.scrollResponder.detach()\n\n    if (this.props.onCoords) {\n      this.props.onCoords(null)\n    }\n  }\n\n  updateSizing() {\n    let { props, context } = this\n\n    if (\n      props.clientWidth !== null && // is sizing stable?\n      this.scrollResponder\n      // ^it's possible to have clientWidth immediately after mount (when returning from print view), but w/o scrollResponder\n    ) {\n      let rootEl = this.rootElRef.current\n\n      if (rootEl.offsetWidth) { // not hidden by css\n        this.coords = new TimelineCoords(\n          this.rootElRef.current,\n          collectCellEls(this.cellElRefs.currentMap, props.tDateProfile.slotDates),\n          props.dateProfile,\n          props.tDateProfile,\n          context.dateEnv,\n          context.isRtl,\n        )\n\n        if (props.onCoords) {\n          props.onCoords(this.coords)\n        }\n\n        this.scrollResponder.update(false) // TODO: wouldn't have to do this if coords were in state\n      }\n    }\n  }\n\n  handleScrollRequest = (request: ScrollRequest) => {\n    let { onScrollLeftRequest } = this.props\n    let { coords } = this\n\n    if (onScrollLeftRequest && coords) {\n      if (request.time) {\n        let scrollLeft = coords.coordFromLeft(coords.durationToCoord(request.time))\n        onScrollLeftRequest(scrollLeft)\n      }\n      return true\n    }\n\n    return null // best?\n  }\n\n  positionToHit(leftPosition) { // TODO: kill somehow\n    let { outerCoordCache } = this.coords\n    let { dateEnv, isRtl } = this.context\n    let { tDateProfile } = this.props\n    let slatIndex = outerCoordCache.leftToIndex(leftPosition)\n\n    if (slatIndex != null) {\n      // somewhat similar to what TimeGrid does. consolidate?\n      let slatWidth = outerCoordCache.getWidth(slatIndex)\n      let partial = isRtl ?\n        (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth :\n        (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth\n      let localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot)\n      let start = dateEnv.add(\n        tDateProfile.slotDates[slatIndex],\n        multiplyDuration(tDateProfile.snapDuration, localSnapIndex),\n      )\n      let end = dateEnv.add(start, tDateProfile.snapDuration)\n\n      return {\n        dateSpan: {\n          range: { start, end },\n          allDay: !this.props.tDateProfile.isTimeScale,\n        },\n        dayEl: this.cellElRefs.currentMap[slatIndex],\n        left: outerCoordCache.lefts[slatIndex], // TODO: make aware of snaps?\n        right: outerCoordCache.rights[slatIndex],\n      }\n    }\n\n    return null\n  }\n}\n\nfunction collectCellEls(elMap: { [key: string]: HTMLElement }, slotDates: DateMarker[]) {\n  return slotDates.map((slotDate) => {\n    let key = slotDate.toISOString()\n    return elMap[key]\n  })\n}\n","import {\n  SegSpan, SegHierarchy, groupIntersectingEntries, SegEntry, buildIsoString,\n  computeEarliestSegStart,\n} from '@fullcalendar/common'\nimport { TimelineCoords } from './TimelineCoords'\nimport { TimelineLaneSeg } from './TimelineLaneSlicer'\n\nexport interface TimelineSegPlacement {\n  seg: TimelineLaneSeg | TimelineLaneSeg[] // HACK: if array, then it's a more-link group\n  hcoords: SegSpan | null\n  top: number | null\n}\n\nexport function computeSegHCoords(\n  segs: TimelineLaneSeg[],\n  minWidth: number,\n  timelineCoords: TimelineCoords | null,\n): SegSpan[] {\n  let hcoords: SegSpan[] = []\n\n  if (timelineCoords) {\n    for (let seg of segs) {\n      let res = timelineCoords.rangeToCoords(seg)\n      let start = Math.round(res.start) // for barely-overlapping collisions\n      let end = Math.round(res.end) //\n\n      if (end - start < minWidth) {\n        end = start + minWidth\n      }\n\n      hcoords.push({ start, end })\n    }\n  }\n\n  return hcoords\n}\n\nexport function computeFgSegPlacements(\n  segs: TimelineLaneSeg[],\n  segHCoords: SegSpan[], // might not have for every seg\n  eventInstanceHeights: { [instanceId: string]: number }, // might not have for every seg\n  moreLinkHeights: { [isoStr: string]: number }, // might not have for every more-link\n  strictOrder?: boolean,\n  maxStackCnt?: number,\n): [TimelineSegPlacement[], number] { // [placements, totalHeight]\n  let segInputs: SegEntry[] = []\n  let crudePlacements: TimelineSegPlacement[] = [] // when we don't know dims\n\n  for (let i = 0; i < segs.length; i += 1) {\n    let seg = segs[i]\n    let instanceId = seg.eventRange.instance.instanceId\n    let height = eventInstanceHeights[instanceId]\n    let hcoords = segHCoords[i]\n\n    if (height && hcoords) {\n      segInputs.push({\n        index: i,\n        span: hcoords,\n        thickness: height,\n      })\n    } else {\n      crudePlacements.push({\n        seg,\n        hcoords, // might as well set hcoords if we have them. might be null\n        top: null,\n      })\n    }\n  }\n\n  let hierarchy = new SegHierarchy()\n  if (strictOrder != null) {\n    hierarchy.strictOrder = strictOrder\n  }\n  if (maxStackCnt != null) {\n    hierarchy.maxStackCnt = maxStackCnt\n  }\n\n  let hiddenEntries = hierarchy.addSegs(segInputs)\n  let hiddenPlacements = hiddenEntries.map((entry) => ({\n    seg: segs[entry.index],\n    hcoords: entry.span,\n    top: null,\n  } as TimelineSegPlacement))\n\n  let hiddenGroups = groupIntersectingEntries(hiddenEntries)\n  let moreLinkInputs: SegEntry[] = []\n  let moreLinkCrudePlacements: TimelineSegPlacement[] = []\n  const extractSeg = (entry: SegEntry) => segs[entry.index]\n\n  for (let i = 0; i < hiddenGroups.length; i += 1) {\n    let hiddenGroup = hiddenGroups[i]\n    let sortedSegs = hiddenGroup.entries.map(extractSeg)\n    let height = moreLinkHeights[buildIsoString(computeEarliestSegStart(sortedSegs))] // not optimal :(\n\n    if (height != null) {\n      // NOTE: the hiddenGroup's spanStart/spanEnd are already computed by rangeToCoords. computed during input.\n      moreLinkInputs.push({\n        index: segs.length + i, // out-of-bounds indexes map to hiddenGroups\n        thickness: height,\n        span: hiddenGroup.span,\n      })\n    } else {\n      moreLinkCrudePlacements.push({\n        seg: sortedSegs, // a Seg array signals a more-link\n        hcoords: hiddenGroup.span,\n        top: null,\n      })\n    }\n  }\n\n  // add more-links into the hierarchy, but don't limit\n  hierarchy.maxStackCnt = -1\n  hierarchy.addSegs(moreLinkInputs)\n\n  let visibleRects = hierarchy.toRects()\n  let visiblePlacements: TimelineSegPlacement[] = []\n  let maxHeight = 0\n\n  for (let rect of visibleRects) {\n    let segIndex = rect.index\n    visiblePlacements.push({\n      seg: segIndex < segs.length\n        ? segs[segIndex] // a real seg\n        : hiddenGroups[segIndex - segs.length].entries.map(extractSeg), // signals a more-link\n      hcoords: rect.span,\n      top: rect.levelCoord,\n    })\n    maxHeight = Math.max(maxHeight, rect.levelCoord + rect.thickness)\n  }\n\n  return [\n    visiblePlacements.concat(crudePlacements, hiddenPlacements, moreLinkCrudePlacements),\n    maxHeight,\n  ]\n}\n","import {\n  BaseComponent, createElement, Fragment, BgEvent, renderFill,\n  getSegMeta, DateRange, DateMarker, buildEventRangeKey,\n} from '@fullcalendar/common'\nimport { computeSegHCoords } from './event-placement'\nimport { coordsToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineLaneSeg } from './TimelineLaneSlicer'\n\nexport interface TimelineLaneBgProps {\n  businessHourSegs: TimelineLaneSeg[] | null // can be null :(\n  bgEventSegs: TimelineLaneSeg[] | null // can be null :(\n  dateSelectionSegs: TimelineLaneSeg[]\n  eventResizeSegs: TimelineLaneSeg[]\n  timelineCoords: TimelineCoords | null\n  todayRange: DateRange\n  nowDate: DateMarker\n}\n\nexport class TimelineLaneBg extends BaseComponent<TimelineLaneBgProps> {\n  render() {\n    let { props } = this\n    let highlightSeg = [].concat(props.eventResizeSegs, props.dateSelectionSegs)\n\n    return props.timelineCoords && (\n      <div className=\"fc-timeline-bg\">\n        {/* Fragments contain the keys */}\n        {this.renderSegs(props.businessHourSegs || [], props.timelineCoords, 'non-business')}\n        {this.renderSegs(props.bgEventSegs || [], props.timelineCoords, 'bg-event')}\n        {this.renderSegs(highlightSeg, props.timelineCoords, 'highlight')}\n      </div>\n    )\n  }\n\n  renderSegs(segs: TimelineLaneSeg[], timelineCoords: TimelineCoords | null, fillType: string) {\n    let { todayRange, nowDate } = this.props\n    let { isRtl } = this.context\n    let segHCoords = computeSegHCoords(segs, 0, timelineCoords)\n\n    let children = segs.map((seg, i) => {\n      let hcoords = segHCoords[i]\n      let hStyle = coordsToCss(hcoords, isRtl)\n\n      return (\n        <div\n          key={buildEventRangeKey(seg.eventRange)}\n          className=\"fc-timeline-bg-harness\"\n          style={hStyle}\n        >\n          {fillType === 'bg-event' ?\n            <BgEvent seg={seg} {...getSegMeta(seg, todayRange, nowDate)} /> :\n            renderFill(fillType)}\n        </div>\n      )\n    })\n\n    return <Fragment>{children}</Fragment>\n  }\n}\n","import {\n  DateRange, intersectRanges, addMs, DateProfile, Slicer,\n  DateProfileGenerator, DateEnv, DateMarker, Seg,\n} from '@fullcalendar/common'\nimport { normalizeRange, isValidDate, TimelineDateProfile } from './timeline-date-profile'\nimport { computeDateSnapCoverage } from './TimelineCoords'\n\nexport interface TimelineLaneSeg extends Seg {\n  // the point of this range is because it might be different than seg.eventRange.range\n  // because the date might have been rounded to the start of a week or a month\n  start: DateMarker\n  end: DateMarker\n}\n\nexport class TimelineLaneSlicer extends Slicer<\n  TimelineLaneSeg,\n  [DateProfile, DateProfileGenerator, TimelineDateProfile, DateEnv]\n> {\n  sliceRange(\n    origRange: DateRange,\n    dateProfile: DateProfile,\n    dateProfileGenerator: DateProfileGenerator,\n    tDateProfile: TimelineDateProfile,\n    dateEnv: DateEnv,\n  ): TimelineLaneSeg[] {\n    let normalRange = normalizeRange(origRange, tDateProfile, dateEnv)\n    let segs: TimelineLaneSeg[] = []\n\n    // protect against when the span is entirely in an invalid date region\n    if (\n      computeDateSnapCoverage(normalRange.start, tDateProfile, dateEnv)\n      < computeDateSnapCoverage(normalRange.end, tDateProfile, dateEnv)\n    ) {\n      // intersect the footprint's range with the grid's range\n      let slicedRange = intersectRanges(normalRange, tDateProfile.normalizedRange)\n\n      if (slicedRange) {\n        segs.push({\n          start: slicedRange.start,\n          end: slicedRange.end,\n          isStart: slicedRange.start.valueOf() === normalRange.start.valueOf()\n            && isValidDate(slicedRange.start, tDateProfile, dateProfile, dateProfileGenerator),\n          isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf()\n            && isValidDate(addMs(slicedRange.end, -1), tDateProfile, dateProfile, dateProfileGenerator),\n        })\n      }\n    }\n\n    return segs\n  }\n}\n","import { StandardEvent, MinimalEventProps, createElement, BaseComponent, createFormatter } from '@fullcalendar/common'\n\nexport interface TimelineEventProps extends MinimalEventProps {\n  isTimeScale: boolean\n}\n\nconst DEFAULT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow',\n})\n\nexport class TimelineEvent extends BaseComponent<TimelineEventProps> {\n  render() {\n    let { props } = this\n\n    return (\n      <StandardEvent\n        {...props}\n        extraClassNames={['fc-timeline-event', 'fc-h-event']}\n        defaultTimeFormat={DEFAULT_TIME_FORMAT}\n        defaultDisplayEventTime={!props.isTimeScale}\n      />\n    )\n  }\n}\n","import {\n  createElement, BaseComponent, Ref, createRef, MoreLinkRoot,\n  setRef, DateProfile, DateRange, DateMarker, Fragment, getSegMeta,\n} from '@fullcalendar/common'\nimport { TimelineSegPlacement } from './event-placement'\nimport { coordsToCss } from './TimelineCoords'\nimport { TimelineEvent } from './TimelineEvent'\nimport { TimelineLaneSeg } from './TimelineLaneSlicer'\n\nexport interface TimelineLaneMoreLinkProps {\n  elRef: Ref<HTMLElement>\n  hiddenSegs: TimelineLaneSeg[]\n  placement: TimelineSegPlacement\n  dateProfile: DateProfile\n  nowDate: DateMarker\n  todayRange: DateRange\n  isTimeScale: boolean\n  eventSelection: string\n  resourceId?: string\n  isForcedInvisible: { [instanceId: string]: any }\n}\n\nexport class TimelineLaneMoreLink extends BaseComponent<TimelineLaneMoreLinkProps> {\n  rootElRef = createRef<HTMLElement>()\n\n  render() {\n    let { props, context } = this\n    let { hiddenSegs, elRef, placement, resourceId } = props\n    let { top, hcoords } = placement\n    let isVisible = hcoords && top !== null\n    let hStyle = coordsToCss(hcoords, context.isRtl)\n    let extraDateSpan = resourceId ? { resourceId } : {}\n\n    return (\n      <MoreLinkRoot\n        allDayDate={null}\n        moreCnt={hiddenSegs.length}\n        allSegs={hiddenSegs}\n        hiddenSegs={hiddenSegs}\n        alignmentElRef={this.rootElRef}\n        dateProfile={props.dateProfile}\n        todayRange={props.todayRange}\n        extraDateSpan={extraDateSpan}\n        popoverContent={() => (\n          <Fragment>\n            {hiddenSegs.map((seg) => {\n              let instanceId = seg.eventRange.instance.instanceId\n              return (\n                <div\n                  key={instanceId}\n                  style={{ visibility: props.isForcedInvisible[instanceId] ? 'hidden' : ('' as any) }}\n                >\n                  <TimelineEvent\n                    isTimeScale={props.isTimeScale}\n                    seg={seg}\n                    isDragging={false}\n                    isResizing={false}\n                    isDateSelecting={false}\n                    isSelected={instanceId === props.eventSelection}\n                    {...getSegMeta(seg, props.todayRange, props.nowDate)}\n                  />\n                </div>\n              )\n            })}\n          </Fragment>\n        )}\n      >\n        {(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) => (\n          <a\n            ref={(el: HTMLElement | null) => {\n              setRef(rootElRef, el) // for MoreLinkRoot\n              setRef(elRef, el) // for props props\n              setRef(this.rootElRef, el) // for this component\n            }}\n            className={['fc-timeline-more-link'].concat(classNames).join(' ')}\n            style={{\n              visibility: isVisible ? ('' as any) : 'hidden',\n              top: top || 0,\n              ...hStyle,\n            }}\n            onClick={handleClick}\n            title={title}\n            aria-expanded={isExpanded}\n            aria-controls={popoverId}\n          >\n            <div ref={innerElRef} className=\"fc-timeline-more-link-inner fc-sticky\">\n              {innerContent}\n            </div>\n          </a>\n        )}\n      </MoreLinkRoot>\n    )\n  }\n}\n","import {\n  Duration, EventStore, EventUiHash, DateSpan, EventInteractionState,\n  BaseComponent, createElement, memoize, Fragment, RefMap, mapHash, createRef,\n  getSegMeta, DateMarker, DateRange, DateProfile, sortEventSegs, isPropsEqual, buildIsoString,\n  computeEarliestSegStart,\n} from '@fullcalendar/common'\nimport { TimelineDateProfile } from './timeline-date-profile'\nimport { coordsToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineLaneBg } from './TimelineLaneBg'\nimport { TimelineLaneSlicer, TimelineLaneSeg } from './TimelineLaneSlicer'\nimport { TimelineEvent } from './TimelineEvent'\nimport { TimelineLaneMoreLink } from './TimelineLaneMoreLink'\nimport { computeFgSegPlacements, computeSegHCoords, TimelineSegPlacement } from './event-placement'\n\nexport interface TimelineLaneProps extends TimelineLaneCoreProps {\n  onHeightChange?: (innerEl: HTMLElement, isStable: boolean) => void\n}\n\nexport interface TimelineLaneCoreProps {\n  nowDate: DateMarker\n  todayRange: DateRange\n  dateProfile: DateProfile\n  tDateProfile: TimelineDateProfile\n  nextDayThreshold: Duration\n  businessHours: EventStore | null\n  eventStore: EventStore | null\n  eventUiBases: EventUiHash\n  dateSelection: DateSpan | null\n  eventSelection: string\n  eventDrag: EventInteractionState | null\n  eventResize: EventInteractionState | null\n  timelineCoords: TimelineCoords | null // TODO: renamt to SLAT coords?\n  resourceId?: string // hack\n}\n\ninterface TimelineLaneState {\n  eventInstanceHeights: { [instanceId: string]: number } // integers\n  moreLinkHeights: { [isoStr: string]: number } // integers\n}\n\nexport class TimelineLane extends BaseComponent<TimelineLaneProps, TimelineLaneState> {\n  private slicer = new TimelineLaneSlicer()\n  private sortEventSegs = memoize(sortEventSegs)\n  private harnessElRefs = new RefMap<HTMLDivElement>()\n  private moreElRefs = new RefMap<HTMLDivElement>()\n  private innerElRef = createRef<HTMLDivElement>()\n  // TODO: memoize event positioning\n\n  state: TimelineLaneState = {\n    eventInstanceHeights: {},\n    moreLinkHeights: {},\n  }\n\n  render() {\n    let { props, state, context } = this\n    let { options } = context\n    let { dateProfile, tDateProfile } = props\n\n    let slicedProps = this.slicer.sliceProps(\n      props,\n      dateProfile,\n      tDateProfile.isTimeScale ? null : props.nextDayThreshold,\n      context, // wish we didn't have to pass in the rest of the args...\n      dateProfile,\n      context.dateProfileGenerator,\n      tDateProfile,\n      context.dateEnv,\n    )\n\n    let mirrorSegs =\n      (slicedProps.eventDrag ? slicedProps.eventDrag.segs as TimelineLaneSeg[] : null) ||\n      (slicedProps.eventResize ? slicedProps.eventResize.segs as TimelineLaneSeg[] : null) ||\n      []\n\n    let fgSegs = this.sortEventSegs(slicedProps.fgEventSegs, options.eventOrder) as TimelineLaneSeg[]\n    let fgSegHCoords = computeSegHCoords(fgSegs, options.eventMinWidth, props.timelineCoords)\n    let [fgPlacements, fgHeight] = computeFgSegPlacements(\n      fgSegs,\n      fgSegHCoords,\n      state.eventInstanceHeights,\n      state.moreLinkHeights,\n      options.eventOrderStrict,\n      options.eventMaxStack,\n    )\n\n    let isForcedInvisible = // TODO: more convenient\n      (slicedProps.eventDrag ? slicedProps.eventDrag.affectedInstances : null) ||\n      (slicedProps.eventResize ? slicedProps.eventResize.affectedInstances : null) ||\n      {}\n\n    return (\n      <Fragment>\n        <TimelineLaneBg\n          businessHourSegs={slicedProps.businessHourSegs}\n          bgEventSegs={slicedProps.bgEventSegs}\n          timelineCoords={props.timelineCoords}\n          eventResizeSegs={slicedProps.eventResize ? slicedProps.eventResize.segs as TimelineLaneSeg[] : [] /* bad new empty array? */}\n          dateSelectionSegs={slicedProps.dateSelectionSegs}\n          nowDate={props.nowDate}\n          todayRange={props.todayRange}\n        />\n        <div\n          className=\"fc-timeline-events fc-scrollgrid-sync-inner\"\n          ref={this.innerElRef}\n          style={{ height: fgHeight }}\n        >\n          {this.renderFgSegs(\n            fgPlacements,\n            isForcedInvisible,\n            false,\n            false,\n            false,\n          )}\n          {this.renderFgSegs(\n            buildMirrorPlacements(mirrorSegs, props.timelineCoords, fgPlacements),\n            {},\n            Boolean(slicedProps.eventDrag),\n            Boolean(slicedProps.eventResize),\n            false, // because mirror is never drawn for date selection\n          )}\n        </div>\n      </Fragment>\n    )\n  }\n\n  componentDidMount() {\n    this.updateSize()\n  }\n\n  componentDidUpdate(prevProps: TimelineLaneProps, prevState: TimelineLaneState) {\n    if (\n      prevProps.eventStore !== this.props.eventStore || // external thing changed?\n      prevProps.timelineCoords !== this.props.timelineCoords || // external thing changed?\n      prevState.moreLinkHeights !== this.state.moreLinkHeights // HACK. see addStateEquality\n    ) {\n      this.updateSize()\n    }\n  }\n\n  updateSize() {\n    let { props } = this\n    let { timelineCoords } = props\n\n    if (props.onHeightChange) {\n      props.onHeightChange(this.innerElRef.current, false)\n    }\n\n    if (timelineCoords) {\n      this.setState({\n        eventInstanceHeights: mapHash(this.harnessElRefs.currentMap, (harnessEl) => (\n          Math.round(harnessEl.getBoundingClientRect().height)\n        )),\n        moreLinkHeights: mapHash(this.moreElRefs.currentMap, (moreEl) => (\n          Math.round(moreEl.getBoundingClientRect().height)\n        )),\n      }, () => {\n        if (props.onHeightChange) {\n          props.onHeightChange(this.innerElRef.current, true)\n        }\n      })\n    }\n  }\n\n  renderFgSegs(\n    segPlacements: TimelineSegPlacement[],\n    isForcedInvisible: { [instanceId: string]: any },\n    isDragging: boolean,\n    isResizing: boolean,\n    isDateSelecting: boolean,\n  ) {\n    let { harnessElRefs, moreElRefs, props, context } = this\n    let isMirror = isDragging || isResizing || isDateSelecting\n\n    return (\n      <Fragment>\n        {segPlacements.map((segPlacement) => {\n          let { seg, hcoords, top } = segPlacement\n\n          if (Array.isArray(seg)) { // a more-link\n            let isoStr = buildIsoString(computeEarliestSegStart(seg))\n            return (\n              <TimelineLaneMoreLink\n                key={'m:' + isoStr /* \"m\" for \"more\" */}\n                elRef={moreElRefs.createRef(isoStr)}\n                hiddenSegs={seg}\n                placement={segPlacement}\n                dateProfile={props.dateProfile}\n                nowDate={props.nowDate}\n                todayRange={props.todayRange}\n                isTimeScale={props.tDateProfile.isTimeScale}\n                eventSelection={props.eventSelection}\n                resourceId={props.resourceId}\n                isForcedInvisible={isForcedInvisible}\n              />\n            )\n          }\n\n          let instanceId = seg.eventRange.instance.instanceId\n          let isVisible = isMirror || Boolean(!isForcedInvisible[instanceId] && hcoords && top !== null)\n          let hStyle = coordsToCss(hcoords, context.isRtl)\n\n          return (\n            <div\n              key={'e:' + instanceId /* \"e\" for \"event\" */}\n              ref={isMirror ? null : harnessElRefs.createRef(instanceId)}\n              className=\"fc-timeline-event-harness\"\n              style={{\n                visibility: isVisible ? ('' as any) : 'hidden',\n                top: top || 0,\n                ...hStyle,\n              }}\n            >\n              <TimelineEvent\n                isTimeScale={props.tDateProfile.isTimeScale}\n                seg={seg}\n                isDragging={isDragging}\n                isResizing={isResizing}\n                isDateSelecting={isDateSelecting}\n                isSelected={instanceId === props.eventSelection /* TODO: bad for mirror? */}\n                {...getSegMeta(seg, props.todayRange, props.nowDate)}\n              />\n            </div>\n          )\n        })}\n      </Fragment>\n    )\n  }\n}\n\nTimelineLane.addStateEquality({\n  eventInstanceHeights: isPropsEqual,\n  moreLinkHeights: isPropsEqual,\n})\n\nfunction buildMirrorPlacements(\n  mirrorSegs: TimelineLaneSeg[],\n  timelineCoords: TimelineCoords | null,\n  fgPlacements: TimelineSegPlacement[],\n): TimelineSegPlacement[] {\n  if (!mirrorSegs.length || !timelineCoords) {\n    return []\n  }\n  let topsByInstanceId = buildAbsoluteTopHash(fgPlacements) // TODO: cache this at first render?\n  return mirrorSegs.map((seg) => ({\n    seg,\n    hcoords: timelineCoords.rangeToCoords(seg),\n    top: topsByInstanceId[seg.eventRange.instance.instanceId],\n  }))\n}\n\nfunction buildAbsoluteTopHash(placements: TimelineSegPlacement[]) {\n  let topsByInstanceId: { [instanceId: string]: number } = {}\n\n  for (let placement of placements) {\n    let { seg } = placement\n    if (!Array.isArray(seg)) { // doesn't represent a more-link\n      topsByInstanceId[seg.eventRange.instance.instanceId] = placement.top\n    }\n  }\n\n  return topsByInstanceId\n}\n","import {\n  createElement, createRef, ViewProps, Hit, DateComponent, CssDimValue, VNode, DateMarker, NowTimer,\n  greatestDurationDenominator, DateRange, NowIndicatorRoot, Fragment,\n} from '@fullcalendar/common'\nimport { coordToCss, TimelineCoords } from './TimelineCoords'\nimport { TimelineSlats } from './TimelineSlats'\nimport { TimelineLane } from './TimelineLane'\nimport { TimelineDateProfile } from './timeline-date-profile'\n\nexport interface TimelinGridProps extends ViewProps {\n  tDateProfile: TimelineDateProfile\n  clientWidth: number | null\n  clientHeight: number | null\n  tableMinWidth: CssDimValue\n  tableColGroupNode: VNode\n  onSlatCoords?: (coords: TimelineCoords) => void\n  onScrollLeftRequest?: (scrollLeft: number) => void\n}\n\ninterface TimelineGridState {\n  coords: TimelineCoords | null\n}\n\nexport class TimelineGrid extends DateComponent<TimelinGridProps, TimelineGridState> {\n  private slatsRef = createRef<TimelineSlats>()\n\n  state: TimelineGridState = {\n    coords: null,\n  }\n\n  render() {\n    let { props, state, context } = this\n    let { options } = context\n    let { dateProfile, tDateProfile } = props\n    let timerUnit = greatestDurationDenominator(tDateProfile.slotDuration).unit\n\n    return (\n      <div\n        className=\"fc-timeline-body\"\n        ref={this.handeEl}\n        style={{\n          minWidth: props.tableMinWidth,\n          height: props.clientHeight,\n          width: props.clientWidth,\n        }}\n      >\n        <NowTimer unit={timerUnit}>\n          {(nowDate: DateMarker, todayRange: DateRange) => (\n            <Fragment>\n              <TimelineSlats\n                ref={this.slatsRef}\n                dateProfile={dateProfile}\n                tDateProfile={tDateProfile}\n                nowDate={nowDate}\n                todayRange={todayRange}\n                clientWidth={props.clientWidth}\n                tableColGroupNode={props.tableColGroupNode}\n                tableMinWidth={props.tableMinWidth}\n                onCoords={this.handleCoords}\n                onScrollLeftRequest={props.onScrollLeftRequest}\n              />\n              <TimelineLane\n                dateProfile={dateProfile}\n                tDateProfile={props.tDateProfile}\n                nowDate={nowDate}\n                todayRange={todayRange}\n                nextDayThreshold={options.nextDayThreshold}\n                businessHours={props.businessHours}\n                eventStore={props.eventStore}\n                eventUiBases={props.eventUiBases}\n                dateSelection={props.dateSelection}\n                eventSelection={props.eventSelection}\n                eventDrag={props.eventDrag}\n                eventResize={props.eventResize}\n                timelineCoords={state.coords}\n              />\n              {(options.nowIndicator && state.coords && state.coords.isDateInRange(nowDate)) && (\n                <div className=\"fc-timeline-now-indicator-container\">\n                  <NowIndicatorRoot isAxis={false} date={nowDate}>\n                    {(rootElRef, classNames, innerElRef, innerContent) => (\n                      <div\n                        ref={rootElRef}\n                        className={['fc-timeline-now-indicator-line'].concat(classNames).join(' ')}\n                        style={coordToCss(state.coords.dateToCoord(nowDate), context.isRtl)}\n                      >\n                        {innerContent}\n                      </div>\n                    )}\n                  </NowIndicatorRoot>\n                </div>\n              )}\n            </Fragment>\n          )}\n        </NowTimer>\n      </div>\n    )\n  }\n\n  handeEl = (el: HTMLElement | null) => {\n    if (el) {\n      this.context.registerInteractiveComponent(this, { el })\n    } else {\n      this.context.unregisterInteractiveComponent(this)\n    }\n  }\n\n  handleCoords = (coords: TimelineCoords) => {\n    this.setState({ coords })\n\n    if (this.props.onSlatCoords) {\n      this.props.onSlatCoords(coords)\n    }\n  }\n\n  // Hit System\n  // ------------------------------------------------------------------------------------------\n\n  queryHit(positionLeft: number, positionTop: number, elWidth: number, elHeight: number): Hit {\n    let slats = this.slatsRef.current\n    let slatHit = slats.positionToHit(positionLeft)\n\n    if (slatHit) {\n      return {\n        dateProfile: this.props.dateProfile,\n        dateSpan: slatHit.dateSpan,\n        rect: {\n          left: slatHit.left,\n          right: slatHit.right,\n          top: 0,\n          bottom: elHeight,\n        },\n        dayEl: slatHit.dayEl,\n        layer: 0,\n      }\n    }\n\n    return null\n  }\n}\n","import {\n  createElement, ViewProps, memoize, ChunkContentCallbackArgs, createRef, ViewRoot,\n  DateComponent, ScrollGridSectionConfig, renderScrollShim, getStickyHeaderDates, getStickyFooterScrollbar,\n} from '@fullcalendar/common'\nimport { ScrollGrid } from '@fullcalendar/scrollgrid'\nimport { buildTimelineDateProfile, TimelineDateProfile } from './timeline-date-profile'\nimport { TimelineHeader } from './TimelineHeader'\nimport { TimelineGrid } from './TimelineGrid'\nimport { TimelineCoords } from './TimelineCoords'\n\ninterface TimelineViewState {\n  slatCoords: TimelineCoords | null\n  slotCushionMaxWidth: number | null\n}\n\nexport class TimelineView extends DateComponent<ViewProps, TimelineViewState> { // would make this abstract, but TS complains\n  private buildTimelineDateProfile = memoize(buildTimelineDateProfile)\n  private scrollGridRef = createRef<ScrollGrid>()\n\n  state = {\n    slatCoords: null,\n    slotCushionMaxWidth: null,\n  }\n\n  render() {\n    let { props, state, context } = this\n    let { options } = context\n    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(options)\n    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(options)\n\n    let tDateProfile = this.buildTimelineDateProfile(\n      props.dateProfile,\n      context.dateEnv,\n      options,\n      context.dateProfileGenerator,\n    )\n\n    let extraClassNames = [\n      'fc-timeline',\n      options.eventOverlap === false ? 'fc-timeline-overlap-disabled' : '',\n    ]\n\n    let { slotMinWidth } = options\n    let slatCols = buildSlatCols(tDateProfile, slotMinWidth || this.computeFallbackSlotMinWidth(tDateProfile))\n\n    let sections: ScrollGridSectionConfig[] = [\n      {\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'timeline',\n          content: (contentArg: ChunkContentCallbackArgs) => (\n            <TimelineHeader\n              dateProfile={props.dateProfile}\n              clientWidth={contentArg.clientWidth}\n              clientHeight={contentArg.clientHeight}\n              tableMinWidth={contentArg.tableMinWidth}\n              tableColGroupNode={contentArg.tableColGroupNode}\n              tDateProfile={tDateProfile}\n              slatCoords={state.slatCoords}\n              onMaxCushionWidth={slotMinWidth ? null : this.handleMaxCushionWidth}\n            />\n          ),\n        }],\n      },\n      {\n        type: 'body',\n        key: 'body',\n        liquid: true,\n        chunks: [{\n          key: 'timeline',\n          content: (contentArg: ChunkContentCallbackArgs) => (\n            <TimelineGrid\n              {...props}\n              clientWidth={contentArg.clientWidth}\n              clientHeight={contentArg.clientHeight}\n              tableMinWidth={contentArg.tableMinWidth}\n              tableColGroupNode={contentArg.tableColGroupNode}\n              tDateProfile={tDateProfile}\n              onSlatCoords={this.handleSlatCoords}\n              onScrollLeftRequest={this.handleScrollLeftRequest}\n            />\n          ),\n        }],\n      },\n    ]\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'timeline',\n          content: renderScrollShim,\n        }],\n      })\n    }\n\n    return (\n      <ViewRoot viewSpec={context.viewSpec}>\n        {(rootElRef, classNames) => (\n          <div ref={rootElRef} className={extraClassNames.concat(classNames).join(' ')}>\n            <ScrollGrid\n              ref={this.scrollGridRef}\n              liquid={!props.isHeightAuto && !props.forPrint}\n              collapsibleWidth={false}\n              colGroups={[\n                { cols: slatCols },\n              ]}\n              sections={sections}\n            />\n          </div>\n        )}\n      </ViewRoot>\n    )\n  }\n\n  handleSlatCoords = (slatCoords: TimelineCoords | null) => {\n    this.setState({ slatCoords })\n  }\n\n  handleScrollLeftRequest = (scrollLeft: number) => {\n    let scrollGrid = this.scrollGridRef.current\n    scrollGrid.forceScrollLeft(0, scrollLeft)\n  }\n\n  handleMaxCushionWidth = (slotCushionMaxWidth) => {\n    this.setState({\n      slotCushionMaxWidth: Math.ceil(slotCushionMaxWidth), // for less rerendering TODO: DRY\n    })\n  }\n\n  computeFallbackSlotMinWidth(tDateProfile: TimelineDateProfile) { // TODO: duplicate definition\n    return Math.max(30, ((this.state.slotCushionMaxWidth || 0) / tDateProfile.slotsPerLabel))\n  }\n}\n\nexport function buildSlatCols(tDateProfile: TimelineDateProfile, slotMinWidth?: number) {\n  return [{\n    span: tDateProfile.slotCnt,\n    minWidth: slotMinWidth || 1, // needs to be a non-zero number to trigger horizontal scrollbars!??????\n  }]\n}\n","import { createPlugin } from '@fullcalendar/common'\n\nimport premiumCommonPlugin from '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n// ensure ambient declarations\nimport '@fullcalendar/premium-common' // eslint-disable-line import/no-duplicates\n\nimport { TimelineView } from './TimelineView'\nimport './main.css'\n\nexport { TimelineView }\nexport { buildSlatCols } from './TimelineView'\nexport { TimelineLane, TimelineLaneProps, TimelineLaneCoreProps } from './TimelineLane'\nexport { TimelineLaneBg } from './TimelineLaneBg'\nexport { TimelineHeader } from './TimelineHeader'\nexport { TimelineSlats } from './TimelineSlats'\nexport { TimelineDateProfile, buildTimelineDateProfile } from './timeline-date-profile'\nexport { TimelineCoords, coordToCss, coordsToCss } from './TimelineCoords'\nexport { TimelineLaneSlicer, TimelineLaneSeg } from './TimelineLaneSlicer'\nexport { TimelineHeaderRows } from './TimelineHeaderRows'\n\nexport default createPlugin({\n  deps: [\n    premiumCommonPlugin,\n  ],\n  initialView: 'timelineDay',\n  views: {\n\n    timeline: {\n      component: TimelineView,\n      usesMinMaxTime: true,\n      eventResizableFromStart: true, // how is this consumed for TimelineView tho?\n    },\n\n    timelineDay: {\n      type: 'timeline',\n      duration: { days: 1 },\n    },\n\n    timelineWeek: {\n      type: 'timeline',\n      duration: { weeks: 1 },\n    },\n\n    timelineMonth: {\n      type: 'timeline',\n      duration: { months: 1 },\n    },\n\n    timelineYear: {\n      type: 'timeline',\n      duration: { years: 1 },\n    },\n\n  },\n})\n"]},"metadata":{},"sourceType":"module"}